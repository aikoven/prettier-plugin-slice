// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Built-in slices Glacier2/Metrics.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:GLACIER2_API\\"]]
[[\\"cpp:doxygen:include:Glacier2/Glacier2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:Glacier2/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:GLACIER2_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Glacier2\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Metrics.ice>

[\\"objc:prefix:ICEMX\\", \\"swift:module:Glacier2:MX\\"]
module IceMX {
  /**
   * Provides information on Glacier2 sessions.
   **/
  class SessionMetrics extends Metrics {
    /**
     * Number of client requests forwared.
     **/
    int forwardedClient = 0;

    /**
     * Number of server requests forwared.
     **/
    int forwardedServer = 0;

    /**
     * The size of the routing table.
     **/
    int routingTableSize = 0;

    /**
     * Number of client requests queued.
     **/
    int queuedClient = 0;

    /**
     * Number of server requests queued.
     **/
    int queuedServer = 0;

    /**
     * Number of client requests overridden.
     **/
    int overriddenClient = 0;

    /**
     * Number of server requests overridden.
     **/
    int overriddenServer = 0;
  };

};
"
`;

exports[`Built-in slices Glacier2/PermissionsVerifier.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:GLACIER2_API\\"]]
[[\\"cpp:doxygen:include:Glacier2/Glacier2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:Glacier2/Config.h\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:GLACIER2_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Glacier2\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Glacier2/SSLInfo.ice>

[\\"objc:prefix:GLACIER2\\"]
module Glacier2 {
  /**
   * This exception is raised if a client is denied the ability to create a
   * session with the router.
   **/
  [\\"preserve-slice\\"]
  exception PermissionDeniedException {
    /**
     * The reason why permission was denied.
     **/
    string reason;
  };

  /**
   * The Glacier2 permissions verifier. This is called through the process of
   * establishing a session.
   *
   * @see Router
   **/
  interface PermissionsVerifier {
    /**
     * Check whether a user has permission to access the router.
     *
     * @param userId The user id for which to check permission.
     *
     * @param password The user's password.
     *
     * @param reason The reason why access was denied.
     *
     * @return True if access is granted, or false otherwise.
     *
     * @throws PermissionDeniedException Raised if the user access is denied.
     * This can be raised in place of returning false with a reason set in the
     * reason out parameter.
     **/
    [\\"nonmutating\\", \\"cpp:const\\", \\"format:sliced\\"]
    idempotent bool checkPermissions(
      string userId,
      string password,
      out string reason
    )
      throws PermissionDeniedException;
  };

  /**
   * The SSL Glacier2 permissions verifier. This is called through the process
   * of establishing a session.
   *
   * @see Router
   **/
  interface SSLPermissionsVerifier {
    /**
     * Check whether a user has permission to access the router.
     *
     * @param info The SSL information.
     *
     * @param reason The reason why access was denied.
     *
     * @return True if access is granted, or false otherwise.
     *
     * @throws PermissionDeniedException Raised if the user access is denied.
     * This can be raised in place of returning false with a reason set in the
     * reason out parameter.
     *
     * @see SSLInfo
     **/
    [\\"nonmutating\\", \\"cpp:const\\", \\"format:sliced\\"]
    idempotent bool authorize(SSLInfo info, out string reason)
      throws PermissionDeniedException;
  };

};
"
`;

exports[`Built-in slices Glacier2/PermissionsVerifierF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:GLACIER2_API\\"]]
[[\\"cpp:doxygen:include:Glacier2/Glacier2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:GLACIER2_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Glacier2\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:GLACIER2\\"]
module Glacier2 {
  interface PermissionsVerifier;
  interface SSLPermissionsVerifier;

};
"
`;

exports[`Built-in slices Glacier2/Router.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:GLACIER2_API\\"]]
[[\\"cpp:doxygen:include:Glacier2/Glacier2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:Glacier2/Config.h\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:GLACIER2_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Glacier2\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Router.ice>
#include <Glacier2/Session.ice>
#include <Glacier2/PermissionsVerifier.ice>

/**
 * Glacier2 is a firewall solution for Ice. Glacier2 authenticates and filters
 * client requests and allows callbacks to the client in a secure fashion. In
 * combination with IceSSL, Glacier2 provides a security solution that is both
 * non-intrusive and easy to configure.
 **/
[\\"objc:prefix:GLACIER2\\"]
module Glacier2 {
  /**
   * This exception is raised if a client tries to destroy a session with a
   * router, but no session exists for the client.
   *
   * @see Router#destroySession
   **/
  exception SessionNotExistException {};

  /**
   * The Glacier2 specialization of the <code>Ice::Router</code> interface.
   **/
  interface Router extends Ice::Router {
    /**
     * This category must be used in the identities of all of the client's
     * callback objects. This is necessary in order for the router to forward
     * callback requests to the intended client. If the Glacier2 server
     * endpoints are not set, the returned category is an empty string.
     *
     * @return The category.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent string getCategoryForClient();

    /**
     * Create a per-client session with the router. If a
     * {@link SessionManager} has been installed, a proxy to a {@link Session} object
     * is returned to the client. Otherwise, null is returned and only an internal
     * session (i.e., not visible to the client) is created.
     *
     * If a session proxy is returned, it must be configured to route through
     * the router that created it. This will happen automatically if the router
     * is configured as the client's default router at the time the session
     * proxy is created in the client process, otherwise the client must
     * configure the session proxy explicitly.
     *
     * @see Session
     * @see SessionManager
     * @see PermissionsVerifier
     *
     * @return A proxy for the newly created session, or null if no
     * {@link SessionManager} has been installed.
     *
     * @param userId The user id for which to check the password.
     *
     * @param password The password for the given user id.
     *
     * @throws PermissionDeniedException Raised if the password for the given
     * user id is not correct, or if the user is not allowed access.
     *
     * @throws CannotCreateSessionException Raised if the session cannot be
     * created.
     **/
    [\\"amd\\", \\"format:sliced\\"]
    Session* createSession(string userId, string password)
      throws PermissionDeniedException, CannotCreateSessionException;

    /**
     * Create a per-client session with the router. The user is authenticated
     * through the SSL certificates that have been associated with the
     * connection. If a {@link SessionManager} has been installed, a proxy to a
     * {@link Session} object is returned to the client. Otherwise, null is
     * returned and only an internal session (i.e., not visible to the client)
     * is created.
     *
     * If a session proxy is returned, it must be configured to route through
     * the router that created it. This will happen automatically if the router
     * is configured as the client's default router at the time the session
     * proxy is created in the client process, otherwise the client must
     * configure the session proxy explicitly.
     *
     * @see Session
     * @see SessionManager
     * @see PermissionsVerifier
     *
     * @return A proxy for the newly created session, or null if no
     * {@link SessionManager} has been installed.
     *
     * @throws PermissionDeniedException Raised if the user cannot be
     * authenticated or if the user is not allowed access.
     *
     * @throws CannotCreateSessionException Raised if the session cannot be
     * created.
     **/
    [\\"amd\\", \\"format:sliced\\"]
    Session* createSessionFromSecureConnection()
      throws PermissionDeniedException, CannotCreateSessionException;

    /**
     * Keep the calling client's session with this router alive.
     *
     * @throws SessionNotExistException Raised if no session exists for the
     * calling client.
     **/
    [\\"amd\\"] void refreshSession() throws SessionNotExistException;

    /**
     * Destroy the calling client's session with this router.
     *
     * @throws SessionNotExistException Raised if no session exists for the
     * calling client.
     **/
    void destroySession() throws SessionNotExistException;

    /**
     * Get the value of the session timeout. Sessions are destroyed if they see
     * no activity for this period of time.
     *
     * @return The timeout (in seconds).
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent long getSessionTimeout();

    /**
     * Get the value of the ACM timeout. Clients supporting connection
     * heartbeats can enable them instead of explicitly sending keep alives
     * requests.
     *
     * NOTE: This method is only available since Ice 3.6.
     *
     * @return The timeout (in seconds).
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent int getACMTimeout();
  };

};
"
`;

exports[`Built-in slices Glacier2/RouterF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:GLACIER2_API\\"]]
[[\\"cpp:doxygen:include:Glacier2/Glacier2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:GLACIER2_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Glacier2\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:GLACIER2\\"]
module Glacier2 {
  interface Router;

};
"
`;

exports[`Built-in slices Glacier2/SSLInfo.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:GLACIER2_API\\"]]
[[\\"cpp:doxygen:include:Glacier2/Glacier2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:Glacier2/Config.h\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:GLACIER2_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Glacier2\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:GLACIER2\\"]
module Glacier2 {
  /**
   * Information taken from an SSL connection used for permissions verification.
   *
   * @see PermissionsVerifier
   **/
  struct SSLInfo {
    string remoteHost;

    int remotePort;

    string localHost;

    int localPort;

    string cipher;

    Ice::StringSeq certs;
  };

};
"
`;

exports[`Built-in slices Glacier2/Session.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:GLACIER2_API\\"]]
[[\\"cpp:doxygen:include:Glacier2/Glacier2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:Glacier2/Config.h\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:GLACIER2_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Glacier2\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>
#include <Ice/Identity.ice>
#include <Glacier2/SSLInfo.ice>

[\\"objc:prefix:GLACIER2\\"]
module Glacier2 {
  /**
   * This exception is raised if an attempt to create a new session failed.
   **/
  [\\"preserve-slice\\"]
  exception CannotCreateSessionException {
    /**
     * The reason why session creation has failed.
     **/
    string reason;
  };

  /**
   * A client-visible session object, which is tied to the lifecycle of a {@link
   * Router}.
   *
   * @see Router
   * @see SessionManager
   **/
  interface Session {
    /**
     * Destroy the session. This is called automatically when the router is
     * destroyed.
     **/
    void destroy();
  };

  /**
   * An object for managing the set of identity constraints for specific parts
   * of object identity on a
   * {@link Session}.
   *
   * @see Session
   * @see SessionControl
   **/
  interface StringSet {
    /**
     * Add a sequence of strings to this set of constraints. Order is not
     * preserved and duplicates are implicitly removed.
     *
     * @param additions The sequence of strings to be added.
     **/
    idempotent void add(Ice::StringSeq additions);

    /**
     * Remove a sequence of strings from this set of constraints. No errors are
     * returned if an entry is not found.
     *
     * @param deletions The sequence of strings to be removed.
     **/
    idempotent void remove(Ice::StringSeq deletions);

    /**
     * Returns a sequence of strings describing the constraints in this set.
     *
     * @return The sequence of strings for this set.
     **/
    idempotent Ice::StringSeq get();
  };

  /**
   * An object for managing the set of object identity constraints on a
   * {@link Session}.
   *
   * @see Session
   * @see SessionControl
   **/
  interface IdentitySet {
    /**
     * Add a sequence of Ice identities to this set of constraints. Order is not
     * preserved and duplicates are implicitly removed.
     *
     * @param additions The sequence of Ice identities to be added.
     **/
    idempotent void add(Ice::IdentitySeq additions);

    /**
     * Remove a sequence of identities from this set of constraints. No errors
     * are returned if an entry is not found.
     *
     * @param deletions The sequence of Ice identities to be removed.
     **/
    idempotent void remove(Ice::IdentitySeq deletions);

    /**
     * Returns a sequence of identities describing the constraints in this set.
     *
     * @return The sequence of Ice identities for this set.
     **/
    idempotent Ice::IdentitySeq get();
  };

  /**
   * An administrative session control object, which is tied to the lifecycle of
   * a {@link Session}.
   *
   * @see Session
   **/
  interface SessionControl {
    /**
     * Access the object that manages the allowable categories for object
     * identities for this session.
     *
     * @return A StringSet object.
     **/
    StringSet* categories();

    /**
     * Access the object that manages the allowable adapter identities for
     * objects for this session.
     *
     * @return A StringSet object.
     **/
    StringSet* adapterIds();

    /**
     * Access the object that manages the allowable object identities for this
     * session.
     *
     * @return An IdentitySet object.
     **/
    IdentitySet* identities();

    /**
     * Get the session timeout.
     *
     * @return The timeout.
     **/
    idempotent int getSessionTimeout();

    /**
     * Destroy the associated session.
     **/
    void destroy();
  };

  /**
   * The session manager for username/password authenticated users that is
   * responsible for managing {@link Session} objects. New session objects are
   * created by the {@link Router} object calling on an application-provided
   * session manager. If no session manager is provided by the application, no
   * client-visible sessions are passed to the client.
   *
   * @see Router
   * @see Session
   **/
  interface SessionManager {
    /**
     * Create a new session.
     *
     * @param userId The user id for the session.
     *
     * @param control A proxy to the session control object.
     *
     * @return A proxy to the newly created session.
     *
     * @throws CannotCreateSessionException Raised if the session cannot be
     * created.
     **/
    [\\"format:sliced\\"]
    Session* create(string userId, SessionControl* control)
      throws CannotCreateSessionException;
  };

  /**
   * The session manager for SSL authenticated users that is responsible for
   * managing {@link Session} objects. New session objects are created by the
   * {@link Router} object calling on an application-provided session manager.
   * If no session manager is provided by the application, no client-visible
   * sessions are passed to the client.
   *
   * @see Router
   * @see Session
   **/
  interface SSLSessionManager {
    /**
     * Create a new session.
     *
     * @param info The SSL info.
     *
     * @param control A proxy to the session control object.
     *
     * @return A proxy to the newly created session.
     *
     * @throws CannotCreateSessionException Raised if the session cannot be
     * created.
     **/
    [\\"format:sliced\\"]
    Session* create(SSLInfo info, SessionControl* control)
      throws CannotCreateSessionException;
  };

};
"
`;

exports[`Built-in slices Ice/BuiltinSequences.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  sequence<bool> BoolSeq;

  sequence<byte> ByteSeq;

  sequence<short> ShortSeq;

  sequence<int> IntSeq;

  sequence<long> LongSeq;

  sequence<float> FloatSeq;

  sequence<double> DoubleSeq;

  sequence<string> StringSeq;

  sequence<Object> ObjectSeq;

  sequence<Object*> ObjectProxySeq;

};
"
`;

exports[`Built-in slices Ice/Communicator.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/LoggerF.ice>
#include <Ice/InstrumentationF.ice>
#include <Ice/ObjectAdapterF.ice>
#include <Ice/ObjectFactory.ice>
#include <Ice/ValueFactory.ice>
#include <Ice/Router.ice>
#include <Ice/Locator.ice>
#include <Ice/PluginF.ice>
#include <Ice/ImplicitContextF.ice>
#include <Ice/Current.ice>
#include <Ice/Properties.ice>
#include <Ice/FacetMap.ice>
#include <Ice/Connection.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * The central object in Ice. One or more communicators can be instantiated
   * for an Ice application. Communicator instantiation is language-specific,
   * and not specified in Slice code.
   *
   * @see Logger
   * @see ObjectAdapter
   * @see Properties
   * @see ValueFactory
   **/
  [\\"clr:implements:global::System.IDisposable\\", \\"java:implements:java.lang.AutoCloseable\\"]
  local interface Communicator {
    /**
     * Destroy the communicator. This operation calls {@link #shutdown}
     * implicitly.  Calling {@link #destroy} cleans up memory, and shuts down
     * this communicator's client functionality and destroys all object
     * adapters. Subsequent calls to {@link #destroy} are ignored.
     *
     * @see #shutdown
     * @see ObjectAdapter#destroy
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\", \\"js:async\\"] void destroy();

    /**
     * Shuts down this communicator's server functionality, which includes the
     * deactivation of all object adapters. Attempts to use a deactivated object
     * adapter raise ObjectAdapterDeactivatedException. Subsequent calls to
     * shutdown are ignored.
     *
     * After shutdown returns, no new requests are processed. However, requests
     * that have been started before shutdown was called might still be active.
     * You can use {@link #waitForShutdown} to wait for the completion of all
     * requests.
     *
     * @see #destroy
     * @see #waitForShutdown
     * @see ObjectAdapter#deactivate
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\", \\"js:async\\"] void shutdown();

    /**
     * Wait until the application has called {@link #shutdown} (or {@link
     * #destroy}). On the server side, this operation blocks the calling thread
     * until all currently-executing operations have completed. On the client
     * side, the operation simply blocks until another thread has called {@link
     * #shutdown} or {@link #destroy}.
     *
     * A typical use of this operation is to call it from the main thread, which
     * then waits until some other thread calls {@link #shutdown}. After
     * shut-down is complete, the main thread returns and can do some cleanup
     * work before it finally calls {@link #destroy} to shut down the client
     * functionality, and then exits the application.
     *
     * @see #shutdown
     * @see #destroy
     * @see ObjectAdapter#waitForDeactivate
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\", \\"js:async\\"] void waitForShutdown();

    /**
     * Check whether communicator has been shut down.
     *
     * @return True if the communicator has been shut down; false otherwise.
     *
     * @see #shutdown
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] bool isShutdown();

    /**
     * Convert a stringified proxy into a proxy. For example,
     * <code>MyCategory/MyObject:tcp -h some_host -p
     * 10000</code> creates a proxy that refers to the Ice object having an
     * identity with a name \\"MyObject\\" and a category
     * \\"MyCategory\\", with the server running on host \\"some_host\\", port
     * 10000. If the stringified proxy does not parse correctly, the operation
     * throws one of ProxyParseException, EndpointParseException, or
     * IdentityParseException. Refer to the Ice manual for a detailed
     * description of the syntax supported by stringified proxies.
     *
     * @param str The stringified proxy to convert into a proxy.
     *
     * @return The proxy, or nil if <code>str</code> is an empty string.
     *
     * @see #proxyToString
     **/
    [\\"cpp:const\\"] Object* stringToProxy(string str);

    /**
     * Convert a proxy into a string.
     *
     * @param obj The proxy to convert into a stringified proxy.
     *
     * @return The stringified proxy, or an empty string if
     * <code>obj</code> is nil.
     *
     * @see #stringToProxy
     **/
    [\\"cpp:const\\", \\"swift:noexcept\\"] string proxyToString(Object* obj);

    /**
     * Convert a set of proxy properties into a proxy. The \\"base\\" name supplied
     * in the <code>property</code> argument refers to a property containing a
     * stringified proxy, such as
     * <code>MyProxy=id:tcp -h localhost -p 10000</code>. Additional properties configure
     * local settings for the proxy, such as
     * <code>MyProxy.PreferSecure=1</code>. The \\"Properties\\" appendix in the Ice
     * manual describes each of the supported proxy properties.
     *
     * @param property The base property name.
     *
     * @return The proxy.
     **/
    [\\"cpp:const\\"] Object* propertyToProxy(string property);

    /**
     * Convert a proxy to a set of proxy properties.
     *
     * @param proxy The proxy.
     *
     * @param property The base property name.
     *
     * @return The property set.
     **/
    [\\"cpp:const\\", \\"swift:noexcept\\"]
    PropertyDict proxyToProperty(
      [\\"swift:nonnull\\"] Object* proxy,
      string property
    );

    /**
     * Convert a string into an identity. If the string does not parse
     * correctly, the operation throws IdentityParseException.
     *
     * @param str The string to convert into an identity.
     *
     * @return The identity.
     *
     * @see #identityToString
     **/
    [\\"cpp:const\\", \\"deprecate:stringToIdentity() is deprecated, use the static stringToIdentity() method instead.\\"]
    Identity stringToIdentity(string str);
    /**
     * Convert an identity into a string.
     *
     * @param ident The identity to convert into a string.
     *
     * @return The \\"stringified\\" identity.
     *
     * @see #stringToIdentity
     **/
    [\\"cpp:const\\", \\"swift:noexcept\\"] string identityToString(Identity ident);

    /**
     * Create a new object adapter. The endpoints for the object adapter are
     * taken from the property <code><em>name</em>.Endpoints</code>.
     *
     * It is legal to create an object adapter with the empty string as its
     * name. Such an object adapter is accessible via bidirectional connections
     * or by collocated invocations that originate from the same communicator as
     * is used by the adapter.
     *
     * Attempts to create a named object adapter for which no configuration can
     * be found raise InitializationException.
     *
     * @param name The object adapter name.
     *
     * @return The new object adapter.
     *
     * @see #createObjectAdapterWithEndpoints
     * @see ObjectAdapter
     * @see Properties
     **/
    [\\"js:async\\", \\"swift:nonnull\\"]
    ObjectAdapter createObjectAdapter(string name);

    /**
     * Create a new object adapter with endpoints. This operation sets the
     * property <code><em>name</em>.Endpoints</code>, and then calls
     * {@link #createObjectAdapter}. It is provided as a convenience function.
     *
     * Calling this operation with an empty name will result in a UUID being
     * generated for the name.
     *
     * @param name The object adapter name.
     *
     * @param endpoints The endpoints for the object adapter.
     *
     * @return The new object adapter.
     *
     * @see #createObjectAdapter
     * @see ObjectAdapter
     * @see Properties
     **/
    [\\"js:async\\", \\"swift:nonnull\\"]
    ObjectAdapter createObjectAdapterWithEndpoints(
      string name,
      string endpoints
    );

    /**
     * Create a new object adapter with a router. This operation creates a
     * routed object adapter.
     *
     * Calling this operation with an empty name will result in a UUID being
     * generated for the name.
     *
     * @param name The object adapter name.
     *
     * @param rtr The router.
     *
     * @return The new object adapter.
     *
     * @see #createObjectAdapter
     * @see ObjectAdapter
     * @see Properties
     **/
    [\\"js:async\\", \\"swift:nonnull\\"]
    ObjectAdapter createObjectAdapterWithRouter(
      string name,
      [\\"objc:param:router\\", \\"swift:nonnull\\"] Router* rtr
    );

    /**
     * Add an object factory to this communicator. Installing a factory with an
     * id for which a factory is already registered throws
     * AlreadyRegisteredException.
     *
     * When unmarshaling an Ice object, the Ice run time reads the most-derived
     * type id off the wire and attempts to create an instance of the type using
     * a factory. If no instance is created, either because no factory was
     * found, or because all factories returned nil, the behavior of the Ice run
     * time depends on the format with which the object was marshaled:
     *
     * If the object uses the \\"sliced\\" format, Ice ascends the class hierarchy
     * until it finds a type that is recognized by a factory, or it reaches the
     * least-derived type. If no factory is found that can create an instance,
     * the run time throws NoValueFactoryException.
     *
     * If the object uses the \\"compact\\" format, Ice immediately raises
     * NoValueFactoryException.
     *
     * The following order is used to locate a factory for a type:
     *
     * <ol>
     *
     * <li>The Ice run-time looks for a factory registered specifically for the
     * type.</li>
     *
     * <li>If no instance has been created, the Ice run-time looks for the
     * default factory, which is registered with an empty type id.
     * </li>
     *
     * <li>If no instance has been created by any of the preceding steps, the
     * Ice run-time looks for a factory that may have been statically generated
     * by the language mapping for non-abstract classes.
     * </li>
     *
     * </ol>
     *
     * @param factory The factory to add.
     *
     * @param id The type id for which the factory can create instances, or an
     * empty string for the default factory.
     *
     * @see #findObjectFactory
     * @see ObjectFactory
     * @see ValueFactoryManager#add
     **/
    [\\"deprecate:addObjectFactory() is deprecated, use ValueFactoryManager::add() instead.\\"]
    void addObjectFactory(
      ObjectFactory factory,
      [\\"objc:param:sliceId\\"] string id
    );

    /**
     * Find an object factory registered with this communicator.
     *
     * @param id The type id for which the factory can create instances, or an
     * empty string for the default factory.
     *
     * @return The object factory, or null if no object factory was found for
     * the given id.
     *
     * @see #addObjectFactory
     * @see ObjectFactory
     * @see ValueFactoryManager#find
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"deprecate:findObjectFactory() is deprecated, use ValueFactoryManager::find() instead.\\"]
    ObjectFactory findObjectFactory(string id);

    /**
     * Get the implicit context associated with this communicator.
     *
     * @return The implicit context associated with this communicator; returns
     * null when the property Ice.ImplicitContext is not set or is set to None.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\", \\"swift:nonnull\\"]
    ImplicitContext getImplicitContext();

    /**
     * Get the properties for this communicator.
     *
     * @return This communicator's properties.
     *
     * @see Properties
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\", \\"swift:nonnull\\"]
    Properties getProperties();

    /**
     * Get the logger for this communicator.
     *
     * @return This communicator's logger.
     *
     * @see Logger
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\", \\"swift:nonnull\\"]
    Logger getLogger();

    /**
     * Get the observer resolver object for this communicator.
     *
     * @return This communicator's observer resolver object.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\"]
    Instrumentation::CommunicatorObserver getObserver();
    /**
     * Get the default router this communicator.
     *
     * @return The default router for this communicator.
     *
     * @see #setDefaultRouter
     * @see Router
     **/
    [\\"cpp:const\\", \\"swift:noexcept\\"] Router* getDefaultRouter();

    /**
     * Set a default router for this communicator. All newly created proxies
     * will use this default router. To disable the default router, null can be
     * used. Note that this operation has no effect on existing proxies.
     *
     * You can also set a router for an individual proxy by calling the
     * operation <code>ice_router</code> on the proxy.
     *
     * @param rtr The default router to use for this communicator.
     *
     * @see #getDefaultRouter
     * @see #createObjectAdapterWithRouter
     * @see Router
     **/
    [\\"swift:noexcept\\"] void setDefaultRouter(Router* rtr);

    /**
     * Get the default locator this communicator.
     *
     * @return The default locator for this communicator.
     *
     * @see #setDefaultLocator
     * @see Locator
     **/
    [\\"cpp:const\\", \\"swift:noexcept\\"] Locator* getDefaultLocator();

    /**
     * Set a default Ice locator for this communicator. All newly created proxy
     * and object adapters will use this default locator. To disable the default
     * locator, null can be used. Note that this operation has no effect on
     * existing proxies or object adapters.
     *
     * You can also set a locator for an individual proxy by calling the
     * operation <code>ice_locator</code> on the proxy, or for an object adapter
     * by calling {@link ObjectAdapter#setLocator} on the object adapter.
     *
     * @param loc The default locator to use for this communicator.
     *
     * @see #getDefaultLocator
     * @see Locator
     * @see ObjectAdapter#setLocator
     **/
    [\\"swift:noexcept\\"] void setDefaultLocator(Locator* loc);

    /**
     * Get the plug-in manager for this communicator.
     *
     * @return This communicator's plug-in manager.
     *
     * @see PluginManager
     **/
    [\\"cpp:const\\"] PluginManager getPluginManager();
    /**
     * Get the value factory manager for this communicator.
     *
     * @return This communicator's value factory manager.
     *
     * @see ValueFactoryManager
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\", \\"swift:nonnull\\"]
    ValueFactoryManager getValueFactoryManager();

    /**
     * Flush any pending batch requests for this communicator. This means all
     * batch requests invoked on fixed proxies for all connections associated
     * with the communicator. Any errors that occur while flushing a connection
     * are ignored.
     *
     * @param compress Specifies whether or not the queued batch requests should
     * be compressed before being sent over the wire.
     **/
    [\\"async-oneway\\"] void flushBatchRequests(CompressBatch compress);

    /**
     * Add the Admin object with all its facets to the provided object adapter.
     * If Ice.Admin.ServerId is set and the provided object adapter has a {@link
     * Locator}, createAdmin registers the Admin's Process facet with the {@link
     * Locator}'s {@link LocatorRegistry}.
     *
     * createAdmin call only be called once; subsequent calls raise
     * InitializationException.
     *
     * @param adminAdapter The object adapter used to host the Admin object; if
     * null and Ice.Admin.Endpoints is set, create, activate and use the
     * Ice.Admin object adapter.
     *
     * @param adminId The identity of the Admin object.
     *
     * @return A proxy to the main (\\"\\") facet of the Admin object. Never returns
     * a null proxy.
     *
     * @see #getAdmin
     **/
    [\\"swift:nonnull\\"]
    Object* createAdmin(ObjectAdapter adminAdapter, Identity adminId);

    /**
     * Get a proxy to the main facet of the Admin object.
     *
     * getAdmin also creates the Admin object and creates and activates the
     * Ice.Admin object adapter to host this Admin object if Ice.Admin.Enpoints
     * is set. The identity of the Admin object created by getAdmin is {value of
     * Ice.Admin.InstanceName}/admin, or {UUID}/admin when
     * Ice.Admin.InstanceName is not set.
     *
     * If Ice.Admin.DelayCreation is 0 or not set, getAdmin is called by the
     * communicator initialization, after initialization of all plugins.
     *
     * @return A proxy to the main (\\"\\") facet of the Admin object, or a null
     * proxy if no Admin object is configured.
     *
     * @see #createAdmin
     **/
    [\\"cpp:const\\"] Object* getAdmin();

    /**
     * Add a new facet to the Admin object. Adding a servant with a facet that
     * is already registered throws AlreadyRegisteredException.
     *
     * @param servant The servant that implements the new Admin facet.
     * @param facet The name of the new Admin facet.
     **/
    void addAdminFacet([\\"swift:nonnull\\"] Object servant, string facet);

    /**
     * Remove the following facet to the Admin object. Removing a facet that was
     * not previously registered throws NotRegisteredException.
     *
     * @param facet The name of the Admin facet.
     * @return The servant associated with this Admin facet.
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    Object removeAdminFacet(string facet);

    /**
     * Returns a facet of the Admin object.
     *
     * @param facet The name of the Admin facet.
     * @return The servant associated with this Admin facet, or null if no facet
     * is registered with the given name.
     **/
    [\\"swift:noexcept\\"] Object findAdminFacet(string facet);

    /**
     * Returns a map of all facets of the Admin object.
     *
     * @return A collection containing all the facet names and servants of the
     * Admin object.
     *
     * @see #findAdminFacet
     **/
    [\\"swift:noexcept\\"] FacetMap findAllAdminFacets();
  };

  /**
   * The output mode for xxxToString method such as identityToString and
   * proxyToString. The actual encoding format for the string is the same for
   * all modes: you don't need to specify an encoding format or mode when
   * reading such a string.
   **/
  local enum ToStringMode {
    /**
     * Characters with ordinal values greater than 127 are kept as-is in the
     * resulting string. Non-printable ASCII characters with ordinal values 127
     * and below are encoded as \\\\\\\\t, \\\\\\\\n (etc.) or \\\\\\\\unnnn.
     **/
    Unicode,

    /**
     * Characters with ordinal values greater than 127 are encoded as universal
     * character names in the resulting string: \\\\\\\\unnnn for BMP characters and
     * \\\\\\\\Unnnnnnnn for non-BMP characters. Non-printable ASCII characters with
     * ordinal values 127 and below are encoded as \\\\\\\\t, \\\\\\\\n (etc.) or \\\\\\\\unnnn.
     **/
    ASCII,

    /**
     * Characters with ordinal values greater than 127 are encoded as a sequence
     * of UTF-8 bytes using octal escapes. Characters with ordinal values 127
     * and below are encoded as \\\\\\\\t, \\\\\\\\n (etc.) or an octal escape. Use this
     * mode to generate strings compatible with Ice 3.6 and earlier.
     **/
    Compat,
  };

};
"
`;

exports[`Built-in slices Ice/CommunicatorF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local interface Communicator;

};
"
`;

exports[`Built-in slices Ice/Connection.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/ObjectAdapterF.ice>
#include <Ice/Identity.ice>
#include <Ice/Endpoint.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * The batch compression option when flushing queued batch requests.
   **/
  [\\"cpp:scoped\\", \\"objc:scoped\\"]
  local enum CompressBatch {
    /**
     * Compress the batch requests.
     **/
    Yes,

    /**
     * Don't compress the batch requests.
     **/
    No,

    /**
     * Compress the batch requests if at least one request was made on a
     * compressed proxy.
     **/
    BasedOnProxy,
  };

  /**
   * Base class providing access to the connection details.
   **/
  local class ConnectionInfo {
    /**
     * The information of the underyling transport or null if there's no
     * underlying transport.
     **/
    ConnectionInfo underlying;

    /**
     * Whether or not the connection is an incoming or outgoing connection.
     **/
    bool incoming;

    /**
     * The name of the adapter associated with the connection.
     **/
    string adapterName;

    /**
     * The connection id.
     **/
    string connectionId;
  };
  local interface Connection;

  /**
   * An application can implement this interface to receive notifications when a
   * connection closes.
   *
   * @see Connection#setCloseCallback
   **/
  [\\"delegate\\"]
  local interface CloseCallback {
    /**
     * This method is called by the the connection when the connection is
     * closed. If the callback needs more information about the closure, it can
     * call {@link Connection#throwException}.
     *
     * @param con The connection that closed.
     **/
    [\\"swift:noexcept\\"] void closed(Connection con);
  };

  /**
   * An application can implement this interface to receive notifications when a
   * connection receives a heartbeat message.
   *
   * @see Connection#setHeartbeatCallback
   **/
  [\\"delegate\\"]
  local interface HeartbeatCallback {
    /**
     * This method is called by the the connection when a heartbeat is received
     * from the peer.
     *
     * @param con The connection on which a heartbeat was received.
     **/
    [\\"swift:noexcept\\"] void heartbeat(Connection con);
  };

  /**
   * Specifies the close semantics for Active Connection Management.
   **/
  local enum ACMClose {
    CloseOff,
    CloseOnIdle,
    /**
     * Forcefully closes a connection that has been idle for the configured
     * timeout period, but only if the connection has pending invocations.
     **/
    CloseOnInvocation,
    CloseOnInvocationAndIdle,
    /**
     * Forcefully closes a connection that has been idle for the configured
     * timeout period, regardless of whether the connection has pending
     * invocations or dispatch.
     **/
    CloseOnIdleForceful,
  };

  /**
   * Specifies the heartbeat semantics for Active Connection Management.
   **/
  local enum ACMHeartbeat {
    HeartbeatOff,
    HeartbeatOnDispatch,
    HeartbeatOnIdle,
    HeartbeatAlways,
  };

  /**
   * A collection of Active Connection Management configuration settings.
   **/
  local struct ACM {
    int timeout;
    ACMClose close;
    ACMHeartbeat heartbeat;
  };

  /**
   * Determines the behavior when manually closing a connection.
   **/
  [\\"cpp:scoped\\", \\"objc:scoped\\"]
  local enum ConnectionClose {
    /**
     * Close the connection immediately without sending a close connection
     * protocol message to the peer and waiting for the peer to acknowledge it.
     **/
    Forcefully,
    /**
     * Close the connection by notifying the peer but do not wait for pending
     * outgoing invocations to complete. On the server side, the connection will
     * not be closed until all incoming invocations have completed.
     **/
    Gracefully,
    /**
     * Wait for all pending invocations to complete before closing the
     * connection.
     **/
    GracefullyWithWait,
  };

  /**
   * The user-level interface to a connection.
   **/
  [\\"swift:inherits:Swift.CustomStringConvertible\\"]
  local interface Connection {
    /**
     * Manually close the connection using the specified closure mode.
     *
     * @param mode Determines how the connection will be closed.
     *
     * @see ConnectionClose
     **/
    [\\"cpp:noexcept\\", \\"js:async\\"] void close(ConnectionClose mode);

    /**
     * Create a special proxy that always uses this connection. This can be used
     * for callbacks from a server to a client if the server cannot directly
     * establish a connection to the client, for example because of firewalls.
     * In this case, the server would create a proxy using an already
     * established connection from the client.
     *
     * @param id The identity for which a proxy is to be created.
     *
     * @return A proxy that matches the given identity and uses this connection.
     *
     * @see #setAdapter
     **/
    [\\"cpp:const\\", \\"swift:nonnull\\"] Object* createProxy(Identity id);

    /**
     * Explicitly set an object adapter that dispatches requests that are
     * received over this connection. A client can invoke an operation on a
     * server using a proxy, and then set an object adapter for the outgoing
     * connection that is used by the proxy in order to receive callbacks. This
     * is useful if the server cannot establish a connection back to the client,
     * for example because of firewalls.
     *
     * @param adapter The object adapter that should be used by this connection
     * to dispatch requests. The object adapter must be activated. When the
     * object adapter is deactivated, it is automatically removed from the
     * connection. Attempts to use a deactivated object adapter raise {@link
     * ObjectAdapterDeactivatedException}
     *
     * @see #createProxy
     * @see #getAdapter
     **/
    void setAdapter(ObjectAdapter adapter);

    /**
     * Get the object adapter that dispatches requests for this connection.
     *
     * @return The object adapter that dispatches requests for the connection,
     * or null if no adapter is set.
     *
     * @see #setAdapter
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] ObjectAdapter getAdapter();

    /**
     * Get the endpoint from which the connection was created.
     *
     * @return The endpoint from which the connection was created.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\", \\"swift:nonnull\\"]
    Endpoint getEndpoint();

    /**
     * Flush any pending batch requests for this connection. This means all
     * batch requests invoked on fixed proxies associated with the connection.
     *
     * @param compress Specifies whether or not the queued batch requests should
     * be compressed before being sent over the wire.
     **/
    [\\"async-oneway\\"] void flushBatchRequests(CompressBatch compress);

    /**
     * Set a close callback on the connection. The callback is called by the
     * connection when it's closed. The callback is called from the Ice thread
     * pool associated with the connection. If the callback needs more
     * information about the closure, it can call {@link
     * Connection#throwException}.
     *
     * @param callback The close callback object.
     **/
    void setCloseCallback(CloseCallback callback);

    /**
     * Set a heartbeat callback on the connection. The callback is called by the
     * connection when a heartbeat is received. The callback is called from the
     * Ice thread pool associated with the connection.
     *
     * @param callback The heartbeat callback object.
     **/
    [\\"swift:noexcept\\"] void setHeartbeatCallback(HeartbeatCallback callback);

    /**
     * Send a heartbeat message.
     **/
    [\\"async-oneway\\"] void heartbeat();

    /**
     * Set the active connection management parameters.
     *
     * @param timeout The timeout value in seconds, must be &gt;= 0.
     *
     * @param close The close condition
     *
     * @param heartbeat The hertbeat condition
     **/
    [\\"swift:noexcept\\", \\"java:optional\\"]
    void setACM(
      optional(1) int timeout,
      optional(2) ACMClose close,
      optional(3) ACMHeartbeat heartbeat
    );

    /**
     * Get the ACM parameters.
     *
     * @return The ACM parameters.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"] ACM getACM();

    /**
     * Return the connection type. This corresponds to the endpoint type, i.e.,
     * \\"tcp\\", \\"udp\\", etc.
     *
     * @return The type of the connection.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] string type();

    /**
     * Get the timeout for the connection.
     *
     * @return The connection's timeout.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] int timeout();

    /**
     * Return a description of the connection as human readable text, suitable
     * for logging or error messages.
     *
     * @return The description of the connection as human readable text.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] string toString();

    /**
     * Returns the connection information.
     *
     * @return The connection information.
     **/
    [\\"cpp:const\\", \\"swift:nonnull\\"] ConnectionInfo getInfo();

    /**
     * Set the connection buffer receive/send size.
     *
     * @param rcvSize The connection receive buffer size.
     * @param sndSize The connection send buffer size.
     **/
    void setBufferSize(int rcvSize, int sndSize);

    /**
     * Throw an exception indicating the reason for connection closure. For
     * example,
     * {@link CloseConnectionException} is raised if the connection was closed gracefully,
     * whereas {@link ConnectionManuallyClosedException} is raised if the connection
     * was manually closed by the application. This operation does nothing if the
     * connection is not yet closed.
     **/
    [\\"cpp:const\\"] void throwException();
  };

  /**
   * Provides access to the connection details of an IP connection
   **/
  local class IPConnectionInfo extends ConnectionInfo {
    string localAddress = \\"\\";

    int localPort = -1;

    string remoteAddress = \\"\\";

    int remotePort = -1;
  };

  /**
   * Provides access to the connection details of a TCP connection
   **/
  local class TCPConnectionInfo extends IPConnectionInfo {
    /**
     * The connection buffer receive size.
     **/
    int rcvSize = 0;

    /**
     * The connection buffer send size.
     **/
    int sndSize = 0;
  };

  /**
   * Provides access to the connection details of a UDP connection
   **/
  local class UDPConnectionInfo extends IPConnectionInfo {
    /**
     * The multicast address.
     **/
    string mcastAddress;

    /**
     * The multicast port.
     **/
    int mcastPort = -1;

    /**
     * The connection buffer receive size.
     **/
    int rcvSize = 0;

    /**
     * The connection buffer send size.
     **/
    int sndSize = 0;
  };

  dictionary<string, string> HeaderDict;

  /**
   * Provides access to the connection details of a WebSocket connection
   **/
  local class WSConnectionInfo extends ConnectionInfo {
    HeaderDict headers;
  };

};
"
`;

exports[`Built-in slices Ice/ConnectionF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local class ConnectionInfo;
  local class WSConnectionInfo;
  local interface Connection;

};
"
`;

exports[`Built-in slices Ice/Current.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/ObjectAdapterF.ice>
#include <Ice/ConnectionF.ice>
#include <Ice/Identity.ice>
#include <Ice/Version.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A request context. <code>Context</code> is used to transmit metadata about
   * a request from the server to the client, such as Quality-of-Service
   * (QoS) parameters. Each operation on the client has a <code>Context</code> as
   * its implicit final parameter.
   **/
  dictionary<string, string> Context;

  enum OperationMode {
    /**
     * Ordinary operations have <code>Normal</code> mode.  These operations
     * modify object state; invoking such an operation twice in a row has
     * different semantics than invoking it once. The Ice run time guarantees
     * that it will not violate at-most-once semantics for
     * <code>Normal</code> operations.
     **/
    Normal,

    /**
     * Operations that use the Slice <code>nonmutating</code> keyword must not
     * modify object state. For C++, nonmutating operations generate
     * <code>const</code> member functions in the skeleton. In addition, the Ice
     * run time will attempt to transparently recover from certain run-time errors
     * by re-issuing a failed request and propagate the failure to the application
     * only if the second attempt fails.
     *
     * <p class=\\"Deprecated\\"><code>Nonmutating</code> is deprecated; Use the
     * <code>idempotent</code> keyword instead. For C++, to retain the mapping of
     * <code>nonmutating</code> operations to C++ <code>const</code> member functions,
     * use the <code>\\\\[\\"cpp:const\\"]</code> metadata directive.
     **/
    Nonmutating,

    /**
     * Operations that use the Slice <code>idempotent</code> keyword can modify
     * object state, but invoking an operation twice in a row must result in the
     * same object state as invoking it once.  For example, <code>x = 1</code>
     * is an idempotent statement, whereas <code>x += 1</code> is not. For
     * idempotent operations, the Ice run-time uses the same retry behavior as
     * for nonmutating operations in case of a potentially recoverable error.
     **/
    Idempotent,
  };

  /**
   * Information about the current method invocation for servers. Each operation
   * on the server has a <code>Current</code> as its implicit final parameter.
   * <code>Current</code> is mostly used for Ice services. Most applications
   * ignore this parameter.
   **/
  local struct Current {
    /**
     * The object adapter.
     **/
    ObjectAdapter adapter;

    /**
     * Information about the connection over which the current method invocation
     * was received. If the invocation is direct due to collocation
     * optimization, this value is set to null.
     **/
    Connection con;

    /**
     * The Ice object identity.
     **/
    Identity id;

    string facet;

    /**
     * The operation name.
     **/
    string operation;

    /**
     * The mode of the operation.
     **/
    OperationMode mode;

    /**
     * The request context, as received from the client.
     **/
    Context ctx;

    /**
     * The request id unless oneway (0).
     **/
    int requestId;

    /**
     * The encoding version used to encode the input and output parameters.
     **/
    EncodingVersion encoding;
  };

};
"
`;

exports[`Built-in slices Ice/Endpoint.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Version.ice>
#include <Ice/BuiltinSequences.ice>
#include <Ice/EndpointF.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * Uniquely identifies TCP endpoints.
   **/
  const short TCPEndpointType = 1;
  /**
   * Uniquely identifies SSL endpoints.
   **/
  const short SSLEndpointType = 2;
  /**
   * Uniquely identifies UDP endpoints.
   **/
  const short UDPEndpointType = 3;
  /**
   * Uniquely identifies TCP-based WebSocket endpoints.
   **/
  const short WSEndpointType = 4;
  /**
   * Uniquely identifies SSL-based WebSocket endpoints.
   **/
  const short WSSEndpointType = 5;
  /**
   * Uniquely identifies Bluetooth endpoints.
   **/
  const short BTEndpointType = 6;
  /**
   * Uniquely identifies SSL Bluetooth endpoints.
   **/
  const short BTSEndpointType = 7;
  /**
   * Uniquely identifies iAP-based endpoints.
   **/
  const short iAPEndpointType = 8;
  /**
   * Uniquely identifies SSL iAP-based endpoints.
   **/
  const short iAPSEndpointType = 9;
  /**
   * Base class providing access to the endpoint details.
   **/
  local class EndpointInfo {
    /**
     * The information of the underyling endpoint of null if there's no
     * underlying endpoint.
     **/
    EndpointInfo underlying;

    /**
     * The timeout for the endpoint in milliseconds. 0 means non-blocking, -1
     * means no timeout.
     **/
    int timeout;

    /**
     * Specifies whether or not compression should be used if available when
     * using this endpoint.
     **/
    bool compress;

    /**
     * Returns the type of the endpoint.
     *
     * @return The endpoint type.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] short type();

    /**
     * Returns true if this endpoint is a datagram endpoint.
     *
     * @return True for a datagram endpoint.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] bool datagram();

    /**
     * Returns true if this endpoint is a secure endpoint.
     *
     * @return True for a secure endpoint.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] bool secure();
  };

  /**
   * The user-level interface to an endpoint.
   **/
  [\\"cpp:comparable\\", \\"js:comparable\\", \\"swift:inherits:Swift.CustomStringConvertible\\"]
  local interface Endpoint {
    /**
     * Return a string representation of the endpoint.
     *
     * @return The string representation of the endpoint.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] string toString();

    /**
     * Returns the endpoint information.
     *
     * @return The endpoint information class.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] EndpointInfo getInfo();
  };

  /**
   * Provides access to the address details of a IP endpoint.
   *
   * @see Endpoint
   **/
  local class IPEndpointInfo extends EndpointInfo {
    /**
     * The host or address configured with the endpoint.
     **/
    string host;

    /**
     * The port number.
     **/
    int port;

    /**
     * The source IP address.
     **/
    string sourceAddress;
  };

  /**
   * Provides access to a TCP endpoint information.
   *
   * @see Endpoint
   **/
  local class TCPEndpointInfo extends IPEndpointInfo {};

  /**
   * Provides access to an UDP endpoint information.
   *
   * @see Endpoint
   **/
  local class UDPEndpointInfo extends IPEndpointInfo {
    /**
     * The multicast interface.
     **/
    string mcastInterface;

    /**
     * The multicast time-to-live (or hops).
     **/
    int mcastTtl;
  };

  /**
   * Provides access to a WebSocket endpoint information.
   **/
  local class WSEndpointInfo extends EndpointInfo {
    /**
     * The URI configured with the endpoint.
     **/
    string resource;
  };

  /**
   * Provides access to the details of an opaque endpoint.
   *
   * @see Endpoint
   **/
  local class OpaqueEndpointInfo extends EndpointInfo {
    /**
     * The encoding version of the opaque endpoint (to decode or encode the
     * rawBytes).
     **/
    EncodingVersion rawEncoding;

    /**
     * The raw encoding of the opaque endpoint.
     **/
    ByteSeq rawBytes;
  };

};
"
`;

exports[`Built-in slices Ice/EndpointF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local class EndpointInfo;
  local class IPEndpointInfo;
  local class TCPEndpointInfo;
  local class UDPEndpointInfo;
  local class WSEndpointInfo;
  local interface Endpoint;

  /**
   * A sequence of endpoints.
   **/
  [\\"swift:nonnull\\"] local sequence<Endpoint> EndpointSeq;

};
"
`;

exports[`Built-in slices Ice/EndpointTypes.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * Determines the order in which the Ice run time uses the endpoints in a
   * proxy when establishing a connection.
   **/
  local enum EndpointSelectionType {
    /**
     * <code>Random</code> causes the endpoints to be arranged in a random
     * order.
     **/
    Random,
    /**
     * <code>Ordered</code> forces the Ice run time to use the endpoints in the
     * order they appeared in the proxy.
     **/
    Ordered,
  };

};
"
`;

exports[`Built-in slices Ice/FacetMap.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A mapping from facet name to servant.
   **/
  local dictionary<string, [\\"swift:nonnull\\"] Object> FacetMap;

};
"
`;

exports[`Built-in slices Ice/Identity.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * The identity of an Ice object. In a proxy, an empty {@link Identity#name}
   * denotes a nil proxy. An identity with an empty {@link Identity#name} and a
   * non-empty {@link Identity#category} is illegal. You cannot add a servant
   * with an empty name to the Active Servant Map.
   *
   * @see ServantLocator
   * @see ObjectAdapter#addServantLocator
   **/
  struct Identity {
    /**
     * The name of the Ice object.
     **/
    string name;

    /**
     * The Ice object category.
     **/
    string category;
  };

  local dictionary<Identity, Object> ObjectDict;
  /**
   * A sequence of identities.
   **/
  sequence<Identity> IdentitySeq;

};
"
`;

exports[`Built-in slices Ice/ImplicitContext.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/LocalException.ice>
#include <Ice/Current.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * An interface to associate implict contexts with communicators.
   *
   * When you make a remote invocation without an explicit context parameter,
   * Ice uses the per-proxy context (if any) combined with the
   * <code>ImplicitContext</code> associated with the communicator.
   *
   * Ice provides several implementations of <code>ImplicitContext</code>. The
   * implementation used depends on the value of the
   * <code>Ice.ImplicitContext</code> property.
   * <dl>
   * <dt><code>None</code> (default)</dt>
   * <dd>No implicit context at all.</dd>
   * <dt><code>PerThread</code></dt>
   * <dd>The implementation maintains a context per thread.</dd>
   * <dt><code>Shared</code></dt>
   * <dd>The implementation maintains a single context shared by all threads.</dd>
   *
   * </dl>
   *
   * <code>ImplicitContext</code> also provides a number of operations to
   * create, update or retrieve an entry in the underlying context without first
   * retrieving a copy of the entire context. These operations correspond to a
   * subset of the <code>java.util.Map</code> methods, with
   * <code>java.lang.Object</code> replaced by <code>string</code> and null
   * replaced by the empty-string.
   **/
  local interface ImplicitContext {
    /**
     * Get a copy of the underlying context.
     * @return A copy of the underlying context.
     **/
    [\\"cpp:const\\", \\"swift:noexcept\\"] Context getContext();

    /**
     * Set the underlying context.
     *
     * @param newContext The new context.
     **/
    [\\"swift:noexcept\\"] void setContext(Context newContext);

    /**
     * Check if this key has an associated value in the underlying context.
     *
     * @param key The key.
     *
     * @return True if the key has an associated value, False otherwise.
     **/
    [\\"cpp:const\\", \\"swift:noexcept\\"] bool containsKey(string key);

    /**
     * Get the value associated with the given key in the underlying context.
     * Returns an empty string if no value is associated with the key.
     * {@link #containsKey} allows you to distinguish between an empty-string value
     * and no value at all.
     *
     * @param key The key.
     *
     * @return The value associated with the key.
     **/
    [\\"cpp:const\\", \\"swift:noexcept\\"] string get(string key);

    /**
     * Create or update a key/value entry in the underlying context.
     *
     * @param key The key.
     *
     * @param value The value.
     *
     * @return The previous value associated with the key, if any.
     **/
    [\\"swift:noexcept\\"] string put(string key, string value);

    /**
     * Remove the entry for the given key in the underlying context.
     *
     * @param key The key.
     *
     * @return The value associated with the key, if any.
     **/
    [\\"swift:noexcept\\"] string remove(string key);
  };
};
"
`;

exports[`Built-in slices Ice/ImplicitContextF.ice 1`] = `
"#pragma once

[[\\"ice-prefix\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"js:module:ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local interface ImplicitContext;

};
"
`;

exports[`Built-in slices Ice/Instrumentation.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/EndpointF.ice>
#include <Ice/ConnectionF.ice>
#include <Ice/Current.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * The Instrumentation local interfaces enable observing a number of Ice core
   * internal components (threads, connections, etc).
   **/
  [\\"objc:prefix:ICEINSTRUMENTATION\\"]
  module Instrumentation {
    /**
     * The object observer interface used by instrumented objects to notify the
     * observer of their existence.
     **/
    local interface Observer {
      /**
       * This method is called when the instrumented object is created or when
       * the observer is attached to an existing object.
       **/
      void attach();

      /**
       * This method is called when the instrumented object is destroyed and as
       * a result the observer detached from the object.
       **/
      void detach();

      /**
       * Notification of a failure.
       *
       * @param exceptionName The name of the exception.
       **/
      void failed(string exceptionName);
    };

    /**
     * The thread state enumeration keeps track of the different possible states
     * of Ice threads.
     **/
    local enum ThreadState {
      /**
       * The thread is idle.
       **/
      ThreadStateIdle,

      /**
       * The thread is in use performing reads or writes for Ice connections.
       * This state is only for threads from an Ice thread pool.
       **/
      ThreadStateInUseForIO,

      /**
       * The thread is calling user code (servant implementation, AMI
       * callbacks). This state is only for threads from an Ice thread pool.
       **/
      ThreadStateInUseForUser,

      /**
       * The thread is performing other internal activities (DNS lookups, timer
       * callbacks, etc).
       **/
      ThreadStateInUseForOther,
    };

    /**
     * The thread observer interface to instrument Ice threads. This can be
     * threads from the Ice thread pool or utility threads used by the Ice core.
     **/
    local interface ThreadObserver extends Observer {
      /**
       * Notification of thread state change.
       *
       * @param oldState The previous thread state.
       *
       * @param newState The new thread state.
       **/
      void stateChanged(ThreadState oldState, ThreadState newState);
    };

    /**
     * The state of an Ice connection.
     **/
    local enum ConnectionState {
      /**
       * The connection is being validated.
       **/
      ConnectionStateValidating,

      /**
       * The connection is holding the reception of new messages.
       **/
      ConnectionStateHolding,

      /**
       * The connection is active and can send and receive messages.
       **/
      ConnectionStateActive,

      /**
       * The connection is being gracefully shutdown and waits for the peer to
       * close its end of the connection.
       **/
      ConnectionStateClosing,

      /**
       * The connection is closed and waits for potential dispatch to be
       * finished before being destroyed and detached from the observer.
       **/
      ConnectionStateClosed,
    };

    /**
     * The connection observer interface to instrument Ice connections.
     **/
    local interface ConnectionObserver extends Observer {
      /**
       * Notification of sent bytes over the connection.
       *
       * @param num The number of bytes sent.
       **/
      void sentBytes(int num);

      /**
       * Notification of received bytes over the connection.
       *
       * @param num The number of bytes received.
       **/
      void receivedBytes(int num);
    };

    /**
     * The dispatch observer to instrument servant dispatch.
     **/
    local interface DispatchObserver extends Observer {
      /**
       * Notification of a user exception.
       **/
      void userException();

      /**
       * Reply notification.
       *
       * @param size The size of the reply.
       **/
      void reply(int size);
    };

    /**
     * The child invocation observer to instrument remote or collocated
     * invocations.
     **/
    local interface ChildInvocationObserver extends Observer {
      /**
       * Reply notification.
       *
       * @param size The size of the reply.
       **/
      void reply(int size);
    };

    /**
     * The remote observer to instrument invocations that are sent over the
     * wire.
     **/
    local interface RemoteObserver extends ChildInvocationObserver {};

    /**
     * The collocated observer to instrument invocations that are collocated.
     **/
    local interface CollocatedObserver extends ChildInvocationObserver {};

    /**
     * The invocation observer to instrument invocations on proxies. A proxy
     * invocation can either result in a collocated or remote invocation. If it
     * results in a remote invocation, a sub-observer is requested for the
     * remote invocation.
     **/
    local interface InvocationObserver extends Observer {
      /**
       * Notification of the invocation being retried.
       **/
      void retried();

      /**
       * Notification of a user exception.
       **/
      void userException();

      /**
       * Get a remote observer for this invocation.
       *
       * @param con The connection information.
       *
       * @param endpt The connection endpoint.
       *
       * @param requestId The ID of the invocation.
       *
       * @param size The size of the invocation.
       *
       * @return The observer to instrument the remote invocation.
       **/
      RemoteObserver getRemoteObserver(
        ConnectionInfo con,
        Endpoint endpt,
        int requestId,
        int size
      );

      /**
       * Get a collocated observer for this invocation.
       *
       * @param adapter The object adapter hosting the collocated Ice object.
       *
       * @param requestId The ID of the invocation.
       *
       * @param size The size of the invocation.
       *
       * @return The observer to instrument the collocated invocation.
       **/
      CollocatedObserver getCollocatedObserver(
        ObjectAdapter adapter,
        int requestId,
        int size
      );
    };

    /**
     * The observer updater interface. This interface is implemented by the Ice
     * run-time and an instance of this interface is provided by the Ice
     * communicator on initialization to the
     * {@link CommunicatorObserver} object set with the communicator initialization
     * data. The Ice communicator calls
     * {@link CommunicatorObserver#setObserverUpdater} to provide the observer
     * updater.
     *
     * This interface can be used by add-ins implementing the
     * {@link CommunicatorObserver} interface to update the observers of connections
     * and threads.
     **/
    local interface ObserverUpdater {
      /**
       * Update connection observers associated with each of the Ice connection
       * from the communicator and its object adapters.
       *
       * When called, this method goes through all the connections and for each
       * connection {@link CommunicatorObserver#getConnectionObserver} is
       * called. The implementation of getConnectionObserver has the possibility
       * to return an updated observer if necessary.
       **/
      void updateConnectionObservers();

      /**
       * Update thread observers associated with each of the Ice thread from the
       * communicator and its object adapters.
       *
       * When called, this method goes through all the threads and for each
       * thread {@link CommunicatorObserver#getThreadObserver} is called. The
       * implementation of getThreadObserver has the possibility to return an
       * updated observer if necessary.
       **/
      void updateThreadObservers();
    };

    /**
     * The communicator observer interface used by the Ice run-time to obtain
     * and update observers for its observable objects. This interface should be
     * implemented by add-ins that wish to observe Ice objects in order to
     * collect statistics. An instance of this interface can be provided to the
     * Ice run-time through the Ice communicator initialization data.
     **/
    local interface CommunicatorObserver {
      /**
       * This method should return an observer for the given endpoint
       * information and connector. The Ice run-time calls this method for each
       * connection establishment attempt.
       *
       * @param endpt The endpoint.
       *
       * @param connector The description of the connector. For IP transports,
       * this is typically the IP address to connect to.
       *
       * @return The observer to instrument the connection establishment.
       **/
      Observer getConnectionEstablishmentObserver(
        Endpoint endpt,
        string connector
      );

      /**
       * This method should return an observer for the given endpoint
       * information. The Ice run-time calls this method to resolve an endpoint
       * and obtain the list of connectors.
       *
       * For IP endpoints, this typically involves doing a DNS lookup to obtain
       * the IP addresses associated with the DNS name.
       *
       * @param endpt The endpoint.
       *
       * @return The observer to instrument the endpoint lookup.
       **/
      Observer getEndpointLookupObserver(Endpoint endpt);

      /**
       * This method should return a connection observer for the given
       * connection. The Ice run-time calls this method for each new connection
       * and for all the Ice communicator connections when
       * {@link ObserverUpdater#updateConnectionObservers} is called.
       *
       * @param c The connection information.
       *
       * @param e The connection endpoint.
       *
       * @param s The state of the connection.
       *
       * @param o The old connection observer if one is already set or a null
       * reference otherwise.
       *
       * @return The connection observer to instrument the connection.
       **/
      ConnectionObserver getConnectionObserver(
        ConnectionInfo c,
        Endpoint e,
        ConnectionState s,
        ConnectionObserver o
      );

      /**
       * This method should return a thread observer for the given thread. The
       * Ice run-time calls this method for each new thread and for all the Ice
       * communicator threads when
       * {@link ObserverUpdater#updateThreadObservers} is called.
       *
       * @param parent The parent of the thread.
       *
       * @param id The ID of the thread to observe.
       *
       * @param s The state of the thread.
       *
       * @param o The old thread observer if one is already set or a null
       * reference otherwise.
       *
       * @return The thread observer to instrument the thread.
       **/
      ThreadObserver getThreadObserver(
        string parent,
        string id,
        ThreadState s,
        ThreadObserver o
      );

      /**
       * This method should return an invocation observer for the given
       * invocation. The Ice run-time calls this method for each new invocation
       * on a proxy.
       *
       * @param prx The proxy used for the invocation.
       *
       * @param operation The name of the invocation.
       *
       * @param ctx The context specified by the user.
       *
       * @return The invocation observer to instrument the invocation.
       **/
      InvocationObserver getInvocationObserver(
        Object* prx,
        string operation,
        Context ctx
      );

      /**
       * This method should return a dispatch observer for the given dispatch.
       * The Ice run-time calls this method each time it receives an incoming
       * invocation to be dispatched for an Ice object.
       *
       * @param c The current object as provided to the Ice servant dispatching
       * the invocation.
       *
       * @param size The size of the dispatch.
       *
       * @return The dispatch observer to instrument the dispatch.
       **/
      DispatchObserver getDispatchObserver(Current c, int size);

      /**
       * The Ice run-time calls this method when the communicator is
       * initialized. The add-in implementing this interface can use this object
       * to get the Ice run-time to re-obtain observers for observed objects.
       *
       * @param updater The observer updater object.
       **/
      void setObserverUpdater(ObserverUpdater updater);
    };

  };

};
"
`;

exports[`Built-in slices Ice/InstrumentationF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  [\\"objc:prefix:ICEINSTRUMENTATION\\"]
  module Instrumentation {
    local interface Observer;
    local interface CommunicatorObserver;

  };

};
"
`;

exports[`Built-in slices Ice/LocalException.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Identity.ice>
#include <Ice/Version.ice>
#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * This exception is raised when a failure occurs during initialization.
   **/
  [\\"cpp:ice_print\\"]
  local exception InitializationException {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception indicates that a failure occurred while initializing a
   * plug-in.
   **/
  [\\"cpp:ice_print\\"]
  local exception PluginInitializationException {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception is raised if a feature is requested that is not supported
   * with collocation optimization.
   **/
  [\\"cpp:ice_print\\", \\"deprecate:This exception is no longer used by the Ice run time\\"]
  local exception CollocationOptimizationException {};

  /**
   * An attempt was made to register something more than once with the Ice run
   * time.
   *
   * This exception is raised if an attempt is made to register a servant,
   * servant locator, facet, value factory, plug-in, object adapter, object, or
   * user exception factory more than once for the same ID.
   **/
  [\\"cpp:ice_print\\"]
  local exception AlreadyRegisteredException {
    /**
     * The kind of object that could not be removed: \\"servant\\", \\"facet\\",
     * \\"object\\", \\"default servant\\", \\"servant locator\\", \\"value factory\\", \\"plugin\\",
     *
     * \\"object adapter\\", \\"object adapter with router\\", \\"replica group\\".
     **/
    string kindOfObject;

    /**
     * The ID (or name) of the object that is registered already.
     **/
    string id;
  };

  /**
   * An attempt was made to find or deregister something that is not registered
   * with the Ice run time or Ice locator.
   *
   * This exception is raised if an attempt is made to remove a servant, servant
   * locator, facet, value factory, plug-in, object adapter, object, or user
   * exception factory that is not currently registered.
   *
   * It's also raised if the Ice locator can't find an object or object adapter
   * when resolving an indirect proxy or when an object adapter is activated.
   **/
  [\\"cpp:ice_print\\"]
  local exception NotRegisteredException {
    /**
     * The kind of object that could not be removed: \\"servant\\", \\"facet\\",
     * \\"object\\", \\"default servant\\", \\"servant locator\\", \\"value factory\\", \\"plugin\\",
     *
     * \\"object adapter\\", \\"object adapter with router\\", \\"replica group\\".
     **/
    string kindOfObject;

    /**
     * The ID (or name) of the object that could not be removed.
     **/
    string id;
  };

  /**
   * The operation can only be invoked with a twoway request.
   *
   * This exception is raised if an attempt is made to invoke an operation with
   * <code>ice_oneway</code>, <code>ice_batchOneway</code>,
   * <code>ice_datagram</code>, or <code>ice_batchDatagram</code> and the
   * operation has a return value, out-parameters, or an exception
   * specification.
   **/
  [\\"cpp:ice_print\\"]
  local exception TwowayOnlyException {
    /**
     * The name of the operation that was invoked.
     **/
    string operation;
  };

  /**
   * An attempt was made to clone a class that does not support cloning.
   *
   * This exception is raised if <code>ice_clone</code> is called on a class
   * that is derived from an abstract Slice class (that is, a class containing
   * operations), and the derived class does not provide an implementation of
   * the <code>ice_clone</code> operation (C++ only).
   **/
  [\\"cpp:ice_print\\"] local exception CloneNotImplementedException {};

  /**
   * This exception is raised if an operation call on a server raises an unknown
   * exception. For example, for C++, this exception is raised if the server
   * throws a C++ exception that is not directly or indirectly derived from
   * <code>Ice::LocalException</code> or
   * <code>Ice::UserException</code>.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnknownException {
    /**
     * This field is set to the textual representation of the unknown exception
     * if available.
     **/
    string unknown;
  };

  /**
   * This exception is raised if an operation call on a server raises a local
   * exception. Because local exceptions are not transmitted by the Ice
   * protocol, the client receives all local exceptions raised by the server as
   * {@link UnknownLocalException}. The only exception to this rule are all
   * exceptions derived from {@link RequestFailedException}, which are
   * transmitted by the Ice protocol even though they are declared
   * <code>local</code>.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnknownLocalException extends UnknownException {};

  /**
   * An operation raised an incorrect user exception.
   *
   * This exception is raised if an operation raises a user exception that is
   * not declared in the exception's
   * <code>throws</code> clause. Such undeclared exceptions are not transmitted from
   * the server to the client by the Ice protocol, but instead the client just gets
   * an
   * {@link UnknownUserException}. This is necessary in order to not violate the
   * contract established by an operation's signature: Only local exceptions and
   * user exceptions declared in the
   * <code>throws</code> clause can be raised.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnknownUserException extends UnknownException {};

  /**
   * This exception is raised if the Ice library version does not match the
   * version in the Ice header files.
   **/
  [\\"cpp:ice_print\\"] local exception VersionMismatchException {};

  /**
   * This exception is raised if the {@link Communicator} has been destroyed.
   *
   * @see Communicator#destroy
   **/
  [\\"cpp:ice_print\\"] local exception CommunicatorDestroyedException {};

  /**
   * This exception is raised if an attempt is made to use a deactivated
   * {@link ObjectAdapter}.
   *
   * @see ObjectAdapter#deactivate
   * @see Communicator#shutdown
   **/
  [\\"cpp:ice_print\\"]
  local exception ObjectAdapterDeactivatedException {
    /**
     * Name of the adapter.
     **/
    string name;
  };

  /**
   * This exception is raised if an {@link ObjectAdapter} cannot be activated.
   *
   * This happens if the {@link Locator} detects another active {@link
   * ObjectAdapter} with the same adapter id.
   **/
  [\\"cpp:ice_print\\"]
  local exception ObjectAdapterIdInUseException {
    /**
     * Adapter ID.
     **/
    string id;
  };

  /**
   * This exception is raised if no suitable endpoint is available.
   **/
  [\\"cpp:ice_print\\"]
  local exception NoEndpointException {
    /**
     * The stringified proxy for which no suitable endpoint is available.
     **/
    string proxy;
  };

  /**
   * This exception is raised if there was an error while parsing an endpoint.
   **/
  [\\"cpp:ice_print\\"]
  local exception EndpointParseException {
    /**
     * Describes the failure and includes the string that could not be parsed.
     **/
    string str;
  };

  /**
   * This exception is raised if there was an error while parsing an endpoint
   * selection type.
   **/
  [\\"cpp:ice_print\\"]
  local exception EndpointSelectionTypeParseException {
    /**
     * Describes the failure and includes the string that could not be parsed.
     **/
    string str;
  };

  /**
   * This exception is raised if there was an error while parsing a version.
   **/
  [\\"cpp:ice_print\\"]
  local exception VersionParseException {
    /**
     * Describes the failure and includes the string that could not be parsed.
     **/
    string str;
  };

  /**
   * This exception is raised if there was an error while parsing a stringified
   * identity.
   **/
  [\\"cpp:ice_print\\"]
  local exception IdentityParseException {
    /**
     * Describes the failure and includes the string that could not be parsed.
     **/
    string str;
  };

  /**
   * This exception is raised if there was an error while parsing a stringified
   * proxy.
   **/
  [\\"cpp:ice_print\\"]
  local exception ProxyParseException {
    /**
     * Describes the failure and includes the string that could not be parsed.
     **/
    string str;
  };

  /**
   * This exception is raised if an illegal identity is encountered.
   **/
  [\\"cpp:ice_print\\"]
  local exception IllegalIdentityException {
    /**
     * The illegal identity.
     **/
    Identity id;
  };

  /**
   * This exception is raised to reject an illegal servant (typically a null
   * servant)
   **/
  [\\"cpp:ice_print\\"]
  local exception IllegalServantException {
    /**
     * Describes why this servant is illegal.
     **/
    string reason;
  };

  /**
   * This exception is raised if a request failed. This exception, and all
   * exceptions derived from {@link RequestFailedException}, are transmitted by
   * the Ice protocol, even though they are declared
   * <code>local</code>.
   **/
  [\\"cpp:ice_print\\"]
  local exception RequestFailedException {
    Identity id;

    string facet;

    string operation;
  };

  /**
   * This exception is raised if an object does not exist on the server, that
   * is, if no facets with the given identity exist.
   **/
  [\\"cpp:ice_print\\"]
  local exception ObjectNotExistException extends RequestFailedException {};

  /**
   * This exception is raised if no facet with the given name exists, but at
   * least one facet with the given identity exists.
   **/
  [\\"cpp:ice_print\\"]
  local exception FacetNotExistException extends RequestFailedException {};

  /**
   * This exception is raised if an operation for a given object does not exist
   * on the server. Typically this is caused by either the client or the server
   * using an outdated Slice specification.
   **/
  [\\"cpp:ice_print\\"]
  local exception OperationNotExistException extends RequestFailedException {};

  /**
   * This exception is raised if a system error occurred in the server or client
   * process. There are many possible causes for such a system exception. For
   * details on the cause, {@link SyscallException#error} should be inspected.
   **/
  [\\"cpp:ice_print\\"]
  local exception SyscallException {
    /**
     * The error number describing the system exception. For C++ and Unix, this
     * is equivalent to <code>errno</code>. For C++ and Windows, this is the
     * value returned by
     * <code>GetLastError()</code> or
     * <code>WSAGetLastError()</code>.
     **/
    int error = 0;
  };

  /**
   * This exception indicates socket errors.
   **/
  [\\"cpp:ice_print\\"] local exception SocketException extends SyscallException {};

  /**
   * This exception indicates CFNetwork errors.
   **/
  [\\"cpp:ice_print\\"]
  local exception CFNetworkException extends SocketException {
    /**
     * The domain of the error.
     **/
    string domain;
  };

  /**
   * This exception indicates file errors.
   **/
  [\\"cpp:ice_print\\"]
  local exception FileException extends SyscallException {
    string path;
  };

  /**
   * This exception indicates connection failures.
   **/
  [\\"cpp:ice_print\\"]
  local exception ConnectFailedException extends SocketException {};

  /**
   * This exception indicates a connection failure for which the server host
   * actively refuses a connection.
   **/
  [\\"cpp:ice_print\\"]
  local exception ConnectionRefusedException extends ConnectFailedException {};

  /**
   * This exception indicates a lost connection.
   **/
  [\\"cpp:ice_print\\"]
  local exception ConnectionLostException extends SocketException {};

  /**
   * This exception indicates a DNS problem. For details on the cause,
   * {@link DNSException#error} should be inspected.
   **/
  [\\"cpp:ice_print\\"]
  local exception DNSException {
    /**
     * The error number describing the DNS problem. For C++ and Unix, this is
     * equivalent to <code>h_errno</code>. For C++ and Windows, this is the
     * value returned by
     * <code>WSAGetLastError()</code>.
     **/
    int error = 0;

    /**
     * The host name that could not be resolved.
     **/
    string host;
  };

  /**
   * This exception indicates a request was interrupted.
   **/
  [\\"cpp:ice_print\\"] local exception OperationInterruptedException {};

  /**
   * This exception indicates a timeout condition.
   **/
  [\\"cpp:ice_print\\"] local exception TimeoutException {};

  /**
   * This exception indicates a connection establishment timeout condition.
   **/
  [\\"cpp:ice_print\\"]
  local exception ConnectTimeoutException extends TimeoutException {};

  /**
   * This exception indicates a connection closure timeout condition.
   **/
  [\\"cpp:ice_print\\"]
  local exception CloseTimeoutException extends TimeoutException {};

  /**
   * This exception indicates that a connection has been shut down because it
   * has been idle for some time.
   **/
  [\\"cpp:ice_print\\"]
  local exception ConnectionTimeoutException extends TimeoutException {};

  /**
   * This exception indicates that an invocation failed because it timed out.
   **/
  [\\"cpp:ice_print\\"]
  local exception InvocationTimeoutException extends TimeoutException {};

  /**
   * This exception indicates that an asynchronous invocation failed because it
   * was canceled explicitly by the user.
   **/
  [\\"cpp:ice_print\\"] local exception InvocationCanceledException {};

  /**
   * A generic exception base for all kinds of protocol error conditions.
   **/
  [\\"cpp:ice_print\\"]
  local exception ProtocolException {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception indicates that a message did not start with the expected
   * magic number ('I', 'c', 'e', 'P').
   **/
  [\\"cpp:ice_print\\"]
  local exception BadMagicException extends ProtocolException {
    /**
     * A sequence containing the first four bytes of the incorrect message.
     **/
    ByteSeq badMagic;
  };

  /**
   * This exception indicates an unsupported protocol version.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnsupportedProtocolException extends ProtocolException {
    /**
     * The version of the unsupported protocol.
     **/
    ProtocolVersion bad;

    /**
     * The version of the protocol that is supported.
     **/
    ProtocolVersion supported;
  };

  /**
   * This exception indicates an unsupported data encoding version.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnsupportedEncodingException extends ProtocolException {
    /**
     * The version of the unsupported encoding.
     **/
    EncodingVersion bad;

    /**
     * The version of the encoding that is supported.
     **/
    EncodingVersion supported;
  };

  /**
   * This exception indicates that an unknown protocol message has been
   * received.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnknownMessageException extends ProtocolException {};

  /**
   * This exception is raised if a message is received over a connection that is
   * not yet validated.
   **/
  [\\"cpp:ice_print\\"]
  local exception ConnectionNotValidatedException extends ProtocolException {};

  /**
   * This exception indicates that a response for an unknown request ID has been
   * received.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnknownRequestIdException extends ProtocolException {};

  /**
   * This exception indicates that an unknown reply status has been received.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnknownReplyStatusException extends ProtocolException {};

  /**
   * This exception indicates that the connection has been gracefully shut down
   * by the server. The operation call that caused this exception has not been
   * executed by the server. In most cases you will not get this exception,
   * because the client will automatically retry the operation call in case the
   * server shut down the connection. However, if upon retry the server shuts
   * down the connection again, and the retry limit has been reached, then this
   * exception is propagated to the application code.
   **/
  [\\"cpp:ice_print\\"]
  local exception CloseConnectionException extends ProtocolException {};

  /**
   * This exception is raised by an operation call if the application closes the
   * connection locally using {@link Connection#close}.
   *
   * @see Connection#close
   **/
  [\\"cpp:ice_print\\"]
  local exception ConnectionManuallyClosedException {
    bool graceful;
  };

  /**
   * This exception indicates that a message size is less than the minimum
   * required size.
   **/
  [\\"cpp:ice_print\\"]
  local exception IllegalMessageSizeException extends ProtocolException {};

  /**
   * This exception indicates a problem with compressing or uncompressing data.
   **/
  [\\"cpp:ice_print\\"]
  local exception CompressionException extends ProtocolException {};

  /**
   * A datagram exceeds the configured size.
   *
   * This exception is raised if a datagram exceeds the configured send or
   * receive buffer size, or exceeds the maximum payload size of a UDP packet
   * (65507 bytes).
   **/
  [\\"cpp:ice_print\\"]
  local exception DatagramLimitException extends ProtocolException {};

  /**
   * This exception is raised for errors during marshaling or unmarshaling data.
   **/
  [\\"cpp:ice_print\\"]
  local exception MarshalException extends ProtocolException {};

  /**
   * This exception is raised if inconsistent data is received while
   * unmarshaling a proxy.
   **/
  [\\"cpp:ice_print\\"]
  local exception ProxyUnmarshalException extends MarshalException {};

  /**
   * This exception is raised if an out-of-bounds condition occurs during
   * unmarshaling.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnmarshalOutOfBoundsException extends MarshalException {};

  /**
   * This exception is raised if no suitable value factory was found during
   * unmarshaling of a Slice class instance.
   *
   * @see ValueFactory
   * @see Communicator#getValueFactoryManager
   * @see ValueFactoryManager#add
   * @see ValueFactoryManager#find
   **/
  [\\"cpp:ice_print\\"]
  local exception NoValueFactoryException extends MarshalException {
    /**
     * The Slice type ID of the class instance for which no no factory could be
     * found.
     **/
    string type;
  };

  /**
   * This exception is raised if the type of an unmarshaled Slice class instance
   * does not match its expected type. This can happen if client and server are
   * compiled with mismatched Slice definitions or if a class of the wrong type
   * is passed as a parameter or return value using dynamic invocation. This
   * exception can also be raised if IceStorm is used to send Slice class
   * instances and an operation is subscribed to the wrong topic.
   **/
  [\\"cpp:ice_print\\"]
  local exception UnexpectedObjectException extends MarshalException {
    /**
     * The Slice type ID of the class instance that was unmarshaled.
     **/
    string type;

    /**
     * The Slice type ID that was expected by the receiving operation.
     **/
    string expectedType;
  };

  /**
   * This exception is raised when Ice receives a request or reply message whose
   * size exceeds the limit specified by the
   * <code>Ice.MessageSizeMax</code> property.
   **/
  [\\"cpp:ice_print\\"]
  local exception MemoryLimitException extends MarshalException {};

  /**
   * This exception is raised when a string conversion to or from UTF-8 fails
   * during marshaling or unmarshaling.
   **/
  [\\"cpp:ice_print\\"]
  local exception StringConversionException extends MarshalException {};

  /**
   * This exception indicates a malformed data encapsulation.
   **/
  [\\"cpp:ice_print\\"]
  local exception EncapsulationException extends MarshalException {};

  /**
   * This exception is raised if an unsupported feature is used. The unsupported
   * feature string contains the name of the unsupported feature
   **/
  [\\"cpp:ice_print\\"]
  local exception FeatureNotSupportedException {
    /**
     * The name of the unsupported feature.
     **/
    string unsupportedFeature;
  };

  /**
   * This exception indicates a failure in a security subsystem, such as the
   * IceSSL plug-in.
   **/
  [\\"cpp:ice_print\\"]
  local exception SecurityException {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception indicates that an attempt has been made to change the
   * connection properties of a fixed proxy.
   **/
  [\\"cpp:ice_print\\"] local exception FixedProxyException {};

  /**
   * Indicates that the response to a request has already been sent;
   * re-dispatching such a request is not possible.
   **/
  [\\"cpp:ice_print\\"] local exception ResponseSentException {};

};
"
`;

exports[`Built-in slices Ice/Locator.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Identity.ice>
#include <Ice/Process.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * This exception is raised if an adapter cannot be found.
   **/
  exception AdapterNotFoundException {};

  /**
   * This exception is raised if the replica group provided by the server is
   * invalid.
   **/
  exception InvalidReplicaGroupIdException {};

  /**
   * This exception is raised if a server tries to set endpoints for an adapter
   * that is already active.
   **/
  exception AdapterAlreadyActiveException {};

  /**
   * This exception is raised if an object cannot be found.
   **/
  exception ObjectNotFoundException {};

  /**
   * This exception is raised if a server cannot be found.
   **/
  exception ServerNotFoundException {};

  interface LocatorRegistry;

  /**
   * The Ice locator interface. This interface is used by clients to lookup
   * adapters and objects. It is also used by servers to get the locator
   * registry proxy.
   *
   * <p class=\\"Note\\">The {@link Locator} interface is intended to be used by Ice
   * internals and by locator implementations. Regular user code should not
   * attempt to use any functionality of this interface directly.
   **/
  interface Locator {
    /**
     * Find an object by identity and return a proxy that contains the adapter
     * ID or endpoints which can be used to access the object.
     *
     * @param id The identity.
     *
     * @return The proxy, or null if the object is not active.
     *
     * @throws ObjectNotFoundException Raised if the object cannot be found.
     **/
    [\\"amd\\", \\"nonmutating\\", \\"cpp:const\\"]
    idempotent Object* findObjectById(Identity id)
      throws ObjectNotFoundException;

    /**
     * Find an adapter by id and return a proxy that contains its endpoints.
     *
     * @param id The adapter id.
     *
     * @return The adapter proxy, or null if the adapter is not active.
     *
     * @throws AdapterNotFoundException Raised if the adapter cannot be found.
     **/
    [\\"amd\\", \\"nonmutating\\", \\"cpp:const\\"]
    idempotent Object* findAdapterById(string id)
      throws AdapterNotFoundException;

    /**
     * Get the locator registry.
     *
     * @return The locator registry.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent LocatorRegistry* getRegistry();
  };

  /**
   * The Ice locator registry interface. This interface is used by servers to
   * register adapter endpoints with the locator.
   *
   * <p class=\\"Note\\"> The {@link LocatorRegistry} interface is intended to be
   * used by Ice internals and by locator implementations. Regular user code
   * should not attempt to use any functionality of this interface directly.
   **/
  interface LocatorRegistry {
    /**
     * Set the adapter endpoints with the locator registry.
     *
     * @param id The adapter id.
     *
     * @param proxy The adapter proxy (a dummy direct proxy created by the
     * adapter). The direct proxy contains the adapter endpoints.
     *
     * @throws AdapterNotFoundException Raised if the adapter cannot be found,
     * or if the locator only allows registered adapters to set their active
     * proxy and the adapter is not registered with the locator.
     *
     * @throws AdapterAlreadyActiveException Raised if an adapter with the same
     * id is already active.
     **/
    [\\"amd\\"]
    idempotent void setAdapterDirectProxy(string id, Object* proxy)
      throws AdapterNotFoundException, AdapterAlreadyActiveException;

    /**
     * Set the adapter endpoints with the locator registry.
     *
     * @param adapterId The adapter id.
     *
     * @param replicaGroupId The replica group id.
     *
     * @param p The adapter proxy (a dummy direct proxy created by the adapter).
     * The direct proxy contains the adapter endpoints.
     *
     * @throws AdapterNotFoundException Raised if the adapter cannot be found,
     * or if the locator only allows registered adapters to set their active
     * proxy and the adapter is not registered with the locator.
     *
     * @throws AdapterAlreadyActiveException Raised if an adapter with the same
     * id is already active.
     *
     * @throws InvalidReplicaGroupIdException Raised if the given replica group
     * doesn't match the one registered with the locator registry for this
     * object adapter.
     **/
    [\\"amd\\"]
    idempotent void setReplicatedAdapterDirectProxy(
      string adapterId,
      string replicaGroupId,
      Object* p
    )
      throws
        AdapterNotFoundException,
        AdapterAlreadyActiveException,
        InvalidReplicaGroupIdException;

    /**
     * Set the process proxy for a server.
     *
     * @param id The server id.
     *
     * @param proxy The process proxy.
     *
     * @throws ServerNotFoundException Raised if the server cannot be found.
     **/
    [\\"amd\\"]
    idempotent void setServerProcessProxy(string id, Process* proxy)
      throws ServerNotFoundException;
  };

  /**
   * This inferface should be implemented by services implementing the
   * Ice::Locator interface. It should be advertised through an Ice object with
   * the identity \`Ice/LocatorFinder'. This allows clients to retrieve the
   * locator proxy with just the endpoint information of the service.
   **/
  interface LocatorFinder {
    /**
     * Get the locator proxy implemented by the process hosting this finder
     * object. The proxy might point to several replicas.
     *
     * @return The locator proxy.
     **/
    Locator* getLocator();
  };

};
"
`;

exports[`Built-in slices Ice/LocatorF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  interface Locator;
  interface LocatorRegistry;

};
"
`;

exports[`Built-in slices Ice/Logger.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * The Ice message logger. Applications can provide their own logger by
   * implementing this interface and installing it in a communicator.
   **/
  local interface Logger {
    /**
     * Print a message. The message is printed literally, without any
     * decorations such as executable name or time stamp.
     *
     * @param message The message to log.
     **/
    [\\"swift:noexcept\\"] void print(string message);

    /**
     * Log a trace message.
     *
     * @param category The trace category.
     *
     * @param message The trace message to log.
     **/
    [\\"swift:noexcept\\"] void trace(string category, string message);

    /**
     * Log a warning message.
     *
     * @param message The warning message to log.
     *
     * @see #error
     **/
    [\\"swift:noexcept\\"] void warning(string message);

    /**
     * Log an error message.
     *
     * @param message The error message to log.
     *
     * @see #warning
     **/
    [\\"swift:noexcept\\"] void error(string message);

    /**
     * Returns this logger's prefix.
     *
     * @return The prefix.
     **/
    [\\"swift:noexcept\\"] string getPrefix();

    /**
     * Returns a clone of the logger with a new prefix.
     *
     * @param prefix The new prefix for the logger.
     * @return A logger instance.
     **/
    [\\"swift:noexcept\\", \\"swift:nonnull\\"] Logger cloneWithPrefix(string prefix);
  };

};
"
`;

exports[`Built-in slices Ice/LoggerF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local interface Logger;

};
"
`;

exports[`Built-in slices Ice/Metrics.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICEMX\\", \\"swift:module:Ice:MX\\"]
module IceMX {
  /**
   * A dictionnary of strings to integers.
   **/
  dictionary<string, int> StringIntDict;

  /**
   * The base class for metrics. A metrics object represents a collection of
   * measurements associated to a given a system.
   **/
  class Metrics {
    /**
     * The metrics identifier.
     **/
    string id;

    /**
     * The total number of objects observed by this metrics. This includes the
     * number of currently observed objects and the number of objects observed
     * in the past.
     **/
    long total = 0;

    /**
     * The number of objects currently observed by this metrics.
     **/
    int current = 0;

    /**
     * The sum of the lifetime of each observed objects. This does not include
     * the lifetime of objects which are currently observed, only the objects
     * observed in the past.
     **/
    long totalLifetime = 0;

    /**
     * The number of failures observed.
     **/
    int failures = 0;
  };

  /**
   * A structure to keep track of failures associated with a given metrics.
   **/
  struct MetricsFailures {
    /**
     * The identifier of the metrics object associated to the failures.
     **/
    string id;

    /**
     * The failures observed for this metrics.
     **/
    StringIntDict failures;
  };

  /**
   * A sequence of {@link MetricsFailures}.
   **/
  sequence<MetricsFailures> MetricsFailuresSeq;

  /**
   * A metrics map is a sequence of metrics. We use a sequence here instead of a
   * map because the ID of the metrics is already included in the Metrics class
   * and using sequences of metrics objects is more efficient than using
   * dictionaries since lookup is not necessary.
   **/
  sequence<Metrics> MetricsMap;

  /**
   * A metrics view is a dictionary of metrics map. The key of the dictionary is
   * the name of the metrics map.
   **/
  dictionary<string, MetricsMap> MetricsView;

  /**
   * Raised if a metrics view cannot be found.
   **/
  exception UnknownMetricsView {};

  /**
   * The metrics administrative facet interface. This interface allows remote
   * administrative clients to access metrics of an application that enabled the
   * Ice administrative facility and configured some metrics views.
   **/
  [\\"format:sliced\\"]
  interface MetricsAdmin {
    /**
     * Get the names of enabled and disabled metrics.
     *
     * @param disabledViews The names of the disabled views.
     *
     * @return The name of the enabled views.
     **/
    Ice::StringSeq getMetricsViewNames(out Ice::StringSeq disabledViews);

    /**
     * Enables a metrics view.
     *
     * @param name The metrics view name.
     *
     * @throws UnknownMetricsView Raised if the metrics view cannot be found.
     **/
    void enableMetricsView(string name) throws UnknownMetricsView;

    /**
     * Disable a metrics view.
     *
     * @param name The metrics view name.
     *
     * @throws UnknownMetricsView Raised if the metrics view cannot be found.
     **/
    void disableMetricsView(string name) throws UnknownMetricsView;

    /**
     * Get the metrics objects for the given metrics view. This returns a
     * dictionnary of metric maps for each metrics class configured with the
     * view. The timestamp allows the client to compute averages which are not
     * dependent of the invocation latency for this operation.
     *
     * @param view The name of the metrics view.
     *
     * @param timestamp The local time of the process when the metrics object
     * were retrieved.
     *
     * @return The metrics view data.
     *
     * @throws UnknownMetricsView Raised if the metrics view cannot be found.
     **/
    MetricsView getMetricsView(string view, out long timestamp)
      throws UnknownMetricsView;

    /**
     * Get the metrics failures associated with the given view and map.
     *
     * @param view The name of the metrics view.
     *
     * @param map The name of the metrics map.
     *
     * @return The metrics failures associated with the map.
     *
     * @throws UnknownMetricsView Raised if the metrics view cannot be found.
     **/
    MetricsFailuresSeq getMapMetricsFailures(string view, string map)
      throws UnknownMetricsView;

    /**
     * Get the metrics failure associated for the given metrics.
     *
     * @param view The name of the metrics view.
     *
     * @param map The name of the metrics map.
     *
     * @param id The ID of the metrics.
     *
     * @return The metrics failures associated with the metrics.
     *
     * @throws UnknownMetricsView Raised if the metrics view cannot be found.
     **/
    MetricsFailures getMetricsFailures(string view, string map, string id)
      throws UnknownMetricsView;
  };

  /**
   * Provides information on the number of threads currently in use and their
   * activity.
   **/
  class ThreadMetrics extends Metrics {
    /**
     * The number of threads which are currently performing socket read or
     * writes.
     **/
    int inUseForIO = 0;

    /**
     * The number of threads which are currently calling user code
     * (servant dispatch, AMI callbacks, etc).
     **/
    int inUseForUser = 0;

    /**
     * The number of threads which are currently performing other activities.
     * These are all other that are not counted with
     * {@link #inUseForUser} or {@link #inUseForIO}, such as DNS lookups, garbage
     * collection).
     **/
    int inUseForOther = 0;
  };

  /**
   * Provides information on servant dispatch.
   **/
  class DispatchMetrics extends Metrics {
    /**
     * The number of dispatch that failed with a user exception.
     **/
    int userException = 0;

    /**
     * The size of the dispatch. This corresponds to the size of the marshalled
     * input parameters.
     **/
    long size = 0;

    /**
     * The size of the dispatch reply. This corresponds to the size of the
     * marshalled output and return parameters.
     **/
    long replySize = 0;
  };

  /**
   * Provides information on child invocations. A child invocation is either
   * remote (sent over an Ice connection) or collocated. An invocation can have
   * multiple child invocation if it is retried. Child invocation metrics are
   * embedded within
   * {@link InvocationMetrics}.
   **/
  class ChildInvocationMetrics extends Metrics {
    /**
     * The size of the invocation. This corresponds to the size of the
     * marshalled input parameters.
     **/
    long size = 0;

    /**
     * The size of the invocation reply. This corresponds to the size of the
     * marshalled output and return parameters.
     **/
    long replySize = 0;
  };

  /**
   * Provides information on invocations that are collocated. Collocated metrics
   * are embedded within {@link InvocationMetrics}.
   **/
  class CollocatedMetrics extends ChildInvocationMetrics {};

  /**
   * Provides information on invocations that are specifically sent over Ice
   * connections. Remote metrics are embedded within {@link InvocationMetrics}.
   **/
  class RemoteMetrics extends ChildInvocationMetrics {};

  /**
   * Provide measurements for proxy invocations. Proxy invocations can either be
   * sent over the wire or be collocated.
   **/
  class InvocationMetrics extends Metrics {
    /**
     * The number of retries for the invocation(s).
     **/
    int retry = 0;

    /**
     * The number of invocations that failed with a user exception.
     **/
    int userException = 0;

    /**
     * The remote invocation metrics map.
     *
     * @see RemoteMetrics
     **/
    MetricsMap remotes;

    /**
     * The collocated invocation metrics map.
     *
     * @see CollocatedMetrics
     **/
    MetricsMap collocated;
  };

  /**
   * Provides information on the data sent and received over Ice connections.
   **/
  class ConnectionMetrics extends Metrics {
    /**
     * The number of bytes received by the connection.
     **/
    long receivedBytes = 0;

    /**
     * The number of bytes sent by the connection.
     **/
    long sentBytes = 0;
  };

};
"
`;

exports[`Built-in slices Ice/ObjectAdapter.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/CommunicatorF.ice>
#include <Ice/ServantLocatorF.ice>
#include <Ice/Locator.ice>
#include <Ice/Identity.ice>
#include <Ice/FacetMap.ice>
#include <Ice/Endpoint.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * The object adapter provides an up-call interface from the Ice run time to
   * the implementation of Ice objects.
   *
   * The object adapter is responsible for receiving requests from endpoints,
   * and for mapping between servants, identities, and proxies.
   *
   * @see Communicator
   * @see ServantLocator
   **/
  local interface ObjectAdapter {
    /**
     * Get the name of this object adapter.
     *
     * @return This object adapter's name.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] string getName();

    /**
     * Get the communicator this object adapter belongs to.
     *
     * @return This object adapter's communicator.
     *
     * @see Communicator
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\", \\"swift:nonnull\\"]
    Communicator getCommunicator();

    /**
     * Activate all endpoints that belong to this object adapter. After
     * activation, the object adapter can dispatch requests received through its
     * endpoints.
     *
     * @see #hold
     * @see #deactivate
     **/
    [\\"js:async\\"] void activate();

    /**
     * Temporarily hold receiving and dispatching requests. The object adapter
     * can be reactivated with the {@link #activate} operation.
     *
     * <p class=\\"Note\\"> Holding is not immediate, i.e., after {@link #hold}
     * returns, the object adapter might still be active for some time. You can
     * use {@link #waitForHold} to wait until holding is complete.
     *
     * @see #activate
     * @see #deactivate
     * @see #waitForHold
     **/
    [\\"swift:noexcept\\"] void hold();

    /**
     * Wait until the object adapter holds requests. Calling {@link #hold}
     * initiates holding of requests, and {@link #waitForHold} only returns when
     * holding of requests has been completed.
     *
     * @see #hold
     * @see #waitForDeactivate
     * @see Communicator#waitForShutdown
     **/
    [\\"swift:noexcept\\", \\"js:async\\"] void waitForHold();

    /**
     * Deactivate all endpoints that belong to this object adapter. After
     * deactivation, the object adapter stops receiving requests through its
     * endpoints. Object adapters that have been deactivated must not be
     * reactivated again, and cannot be used otherwise. Attempts to use a
     * deactivated object adapter raise
     * {@link ObjectAdapterDeactivatedException} however, attempts to
     * {@link #deactivate} an already deactivated object adapter are ignored and
     * do nothing. Once deactivated, it is possible to destroy the adapter to
     * clean up resources and then create and activate a new adapter with the
     * same name.
     *
     * <p class=\\"Note\\"> After {@link #deactivate} returns, no new requests are
     * processed by the object adapter. However, requests that have been started
     * before {@link #deactivate} was called might still be active. You can use
     * {@link #waitForDeactivate} to wait for the completion of all requests for
     * this object adapter.
     *
     * @see #activate
     * @see #hold
     * @see #waitForDeactivate
     * @see Communicator#shutdown
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\", \\"js:async\\"] void deactivate();

    /**
     * Wait until the object adapter has deactivated. Calling
     * {@link #deactivate} initiates object adapter deactivation, and
     * {@link #waitForDeactivate} only returns when deactivation has been
     * completed.
     *
     * @see #deactivate
     * @see #waitForHold
     * @see Communicator#waitForShutdown
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\", \\"js:async\\"] void waitForDeactivate();

    /**
     * Check whether object adapter has been deactivated.
     *
     * @return Whether adapter has been deactivated.
     *
     * @see Communicator#shutdown
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] bool isDeactivated();

    /**
     * Destroys the object adapter and cleans up all resources held by the
     * object adapter. If the object adapter has not yet been deactivated,
     * destroy implicitly initiates the deactivation and waits for it to finish.
     * Subsequent calls to destroy are ignored. Once destroy has returned, it is
     * possible to create another object adapter with the same name.
     *
     * @see #deactivate
     * @see #waitForDeactivate
     * @see Communicator#destroy
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\", \\"js:async\\"] void destroy();

    /**
     * Add a servant to this object adapter's Active Servant Map. Note that one
     * servant can implement several Ice objects by registering the servant with
     * multiple identities. Adding a servant with an identity that is in the map
     * already throws {@link AlreadyRegisteredException}.
     *
     * @param servant The servant to add.
     *
     * @param id The identity of the Ice object that is implemented by the
     * servant.
     *
     * @return A proxy that matches the given identity and this object adapter.
     *
     * @see Identity
     * @see #addFacet
     * @see #addWithUUID
     * @see #remove
     * @see #find
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    Object* add(
      [\\"swift:nonnull\\"] Object servant,
      [\\"objc:param:identity\\"] Identity id
    );

    /**
     * Like {@link #add}, but with a facet. Calling <code>add(servant,
     * id)</code> is equivalent to calling {@link #addFacet} with an empty
     * facet.
     *
     * @param servant The servant to add.
     *
     * @param id The identity of the Ice object that is implemented by the
     * servant.
     *
     * @param facet The facet. An empty facet means the default facet.
     *
     * @return A proxy that matches the given identity, facet, and this object
     * adapter.
     *
     * @see Identity
     * @see #add
     * @see #addFacetWithUUID
     * @see #removeFacet
     * @see #findFacet
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    Object* addFacet(
      [\\"swift:nonnull\\"] Object servant,
      [\\"objc:param:identity\\"] Identity id,
      string facet
    );

    /**
     * Add a servant to this object adapter's Active Servant Map, using an
     * automatically generated UUID as its identity. Note that the generated
     * UUID identity can be accessed using the proxy's
     * <code>ice_getIdentity</code> operation.
     *
     * @param servant The servant to add.
     *
     * @return A proxy that matches the generated UUID identity and this object
     * adapter.
     *
     * @see Identity
     * @see #add
     * @see #addFacetWithUUID
     * @see #remove
     * @see #find
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    Object* addWithUUID([\\"swift:nonnull\\"] Object servant);

    /**
     * Like {@link #addWithUUID}, but with a facet. Calling
     * <code>addWithUUID(servant)</code> is equivalent to calling
     * {@link #addFacetWithUUID} with an empty facet.
     *
     * @param servant The servant to add.
     *
     * @param facet The facet. An empty facet means the default facet.
     *
     * @return A proxy that matches the generated UUID identity, facet, and this
     * object adapter.
     *
     * @see Identity
     * @see #addFacet
     * @see #addWithUUID
     * @see #removeFacet
     * @see #findFacet
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    Object* addFacetWithUUID([\\"swift:nonnull\\"] Object servant, string facet);

    /**
     * Add a default servant to handle requests for a specific category. Adding
     * a default servant for a category for which a default servant is already
     * registered throws
     * {@link AlreadyRegisteredException}. To dispatch operation calls on servants,
     * the object adapter tries to find a servant for a given Ice object identity
     * and facet in the following order:
     *
     * <ol>
     *
     * <li>The object adapter tries to find a servant for the identity and facet
     * in the Active Servant Map.</li>
     *
     * <li>If no servant has been found in the Active Servant Map, the object
     * adapter tries to find a default servant for the category component of the
     * identity.</li>
     *
     * <li>If no servant has been found by any of the preceding steps, the
     * object adapter tries to find a default servant for an empty category,
     * regardless of the category contained in the identity.</li>
     *
     * <li>If no servant has been found by any of the preceding steps, the
     * object adapter gives up and the caller receives
     * {@link ObjectNotExistException} or {@link FacetNotExistException}.</li>
     *
     * </ol>
     *
     * @param servant The default servant.
     *
     * @param category The category for which the default servant is registered.
     * An empty category means it will handle all categories.
     *
     * @see #removeDefaultServant
     * @see #findDefaultServant
     **/
    void addDefaultServant([\\"swift:nonnull\\"] Object servant, string category);

    /**
     * Remove a servant (that is, the default facet) from the object adapter's
     * Active Servant Map.
     *
     * @param id The identity of the Ice object that is implemented by the
     * servant. If the servant implements multiple Ice objects,
     * {@link #remove} has to be called for all those Ice objects. Removing an identity
     * that is not in the map throws
     * {@link NotRegisteredException}.
     *
     * @return The removed servant.
     *
     * @see Identity
     * @see #add
     * @see #addWithUUID
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    Object remove(Identity id);

    /**
     * Like {@link #remove}, but with a facet. Calling <code>remove(id)</code>
     * is equivalent to calling {@link #removeFacet} with an empty facet.
     *
     * @param id The identity of the Ice object that is implemented by the
     * servant.
     *
     * @param facet The facet. An empty facet means the default facet.
     *
     * @return The removed servant.
     *
     * @see Identity
     * @see #addFacet
     * @see #addFacetWithUUID
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    Object removeFacet(Identity id, string facet);

    /**
     * Remove all facets with the given identity from the Active Servant Map.
     * The operation completely removes the Ice object, including its default
     * facet. Removing an identity that is not in the map throws {@link
     * NotRegisteredException}.
     *
     * @param id The identity of the Ice object to be removed.
     *
     * @return A collection containing all the facet names and servants of the
     * removed Ice object.
     *
     * @see #remove
     * @see #removeFacet
     **/
    [\\"swift:attribute:@discardableResult\\"]
    FacetMap removeAllFacets(Identity id);

    /**
     * Remove the default servant for a specific category. Attempting to remove
     * a default servant for a category that is not registered throws {@link
     * NotRegisteredException}.
     *
     * @param category The category of the default servant to remove.
     *
     * @return The default servant.
     *
     * @see #addDefaultServant
     * @see #findDefaultServant
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    Object removeDefaultServant(string category);

    /**
     * Look up a servant in this object adapter's Active Servant Map by the
     * identity of the Ice object it implements.
     *
     * <p class=\\"Note\\">This operation only tries to look up a servant in the
     * Active Servant Map. It does not attempt to find a servant by using any
     * installed {@link ServantLocator}.
     *
     * @param id The identity of the Ice object for which the servant should be
     * returned.
     *
     * @return The servant that implements the Ice object with the given
     * identity, or null if no such servant has been found.
     *
     * @see Identity
     * @see #findFacet
     * @see #findByProxy
     **/
    [\\"swift:noexcept\\", \\"cpp:const\\"] Object find(Identity id);

    /**
     * Like {@link #find}, but with a facet. Calling <code>find(id)</code> is
     * equivalent to calling {@link #findFacet} with an empty facet.
     *
     * @param id The identity of the Ice object for which the servant should be
     * returned.
     *
     * @param facet The facet. An empty facet means the default facet.
     *
     * @return The servant that implements the Ice object with the given
     * identity and facet, or null if no such servant has been found.
     *
     * @see Identity
     * @see #find
     * @see #findByProxy
     **/
    [\\"swift:noexcept\\", \\"cpp:const\\"] Object findFacet(Identity id, string facet);

    /**
     * Find all facets with the given identity in the Active Servant Map.
     *
     * @param id The identity of the Ice object for which the facets should be
     * returned.
     *
     * @return A collection containing all the facet names and servants that
     * have been found, or an empty map if there is no facet for the given
     * identity.
     *
     * @see #find
     * @see #findFacet
     **/
    [\\"swift:noexcept\\", \\"cpp:const\\"] FacetMap findAllFacets(Identity id);

    /**
     * Look up a servant in this object adapter's Active Servant Map, given a
     * proxy.
     *
     * <p class=\\"Note\\">This operation only tries to lookup a servant in the
     * Active Servant Map. It does not attempt to find a servant by using any
     * installed {@link ServantLocator}.
     *
     * @param proxy The proxy for which the servant should be returned.
     *
     * @return The servant that matches the proxy, or null if no such servant
     * has been found.
     *
     * @see #find
     * @see #findFacet
     **/
    [\\"swift:noexcept\\", \\"cpp:const\\"]
    Object findByProxy([\\"swift:nonnull\\"] Object* proxy);

    /**
     * Add a Servant Locator to this object adapter. Adding a servant locator
     * for a category for which a servant locator is already registered throws
     * {@link AlreadyRegisteredException}. To dispatch operation calls on
     * servants, the object adapter tries to find a servant for a given Ice
     * object identity and facet in the following order:
     *
     * <ol>
     *
     * <li>The object adapter tries to find a servant for the identity and facet
     * in the Active Servant Map.</li>
     *
     * <li>If no servant has been found in the Active Servant Map, the object
     * adapter tries to find a servant locator for the category component of the
     * identity. If a locator is found, the object adapter tries to find a
     * servant using this locator.</li>
     *
     * <li>If no servant has been found by any of the preceding steps, the
     * object adapter tries to find a locator for an empty category, regardless
     * of the category contained in the identity. If a locator is found, the
     * object adapter tries to find a servant using this locator.</li>
     *
     * <li>If no servant has been found by any of the preceding steps, the
     * object adapter gives up and the caller receives
     * {@link ObjectNotExistException} or {@link FacetNotExistException}.</li>
     *
     * </ol>
     *
     * <p class=\\"Note\\">Only one locator for the empty category can be installed.
     *
     * @param locator The locator to add.
     *
     * @param category The category for which the Servant Locator can locate
     * servants, or an empty string if the Servant Locator does not belong to
     * any specific category.
     *
     * @see Identity
     * @see #removeServantLocator
     * @see #findServantLocator
     * @see ServantLocator
     **/
    void addServantLocator(
      [\\"swift:nonnull\\"] ServantLocator locator,
      string category
    );

    /**
     * Remove a Servant Locator from this object adapter.
     *
     * @param category The category for which the Servant Locator can locate
     * servants, or an empty string if the Servant Locator does not belong to
     * any specific category.
     *
     * @return The Servant Locator, or throws {@link NotRegisteredException} if
     * no Servant Locator was found for the given category.
     *
     * @see Identity
     * @see #addServantLocator
     * @see #findServantLocator
     * @see ServantLocator
     **/
    [\\"swift:nonnull\\", \\"swift:attribute:@discardableResult\\"]
    ServantLocator removeServantLocator(string category);

    /**
     * Find a Servant Locator installed with this object adapter.
     *
     * @param category The category for which the Servant Locator can locate
     * servants, or an empty string if the Servant Locator does not belong to
     * any specific category.
     *
     * @return The Servant Locator, or null if no Servant Locator was found for
     * the given category.
     *
     * @see Identity
     * @see #addServantLocator
     * @see #removeServantLocator
     * @see ServantLocator
     **/
    [\\"swift:noexcept\\", \\"cpp:const\\"]
    ServantLocator findServantLocator(string category);

    /**
     * Find the default servant for a specific category.
     *
     * @param category The category of the default servant to find.
     *
     * @return The default servant or null if no default servant was registered
     * for the category.
     *
     * @see #addDefaultServant
     * @see #removeDefaultServant
     **/
    [\\"swift:noexcept\\", \\"cpp:const\\"] Object findDefaultServant(string category);

    /**
     * Create a proxy for the object with the given identity. If this object
     * adapter is configured with an adapter id, the return value is an indirect
     * proxy that refers to the adapter id. If a replica group id is also
     * defined, the return value is an indirect proxy that refers to the replica
     * group id. Otherwise, if no adapter id is defined, the return value is a
     * direct proxy containing this object adapter's published endpoints.
     *
     * @param id The object's identity.
     *
     * @return A proxy for the object with the given identity.
     *
     * @see Identity
     **/
    [\\"cpp:const\\", \\"swift:nonnull\\"] Object* createProxy(Identity id);

    /**
     * Create a direct proxy for the object with the given identity. The
     * returned proxy contains this object adapter's published endpoints.
     *
     * @param id The object's identity.
     *
     * @return A proxy for the object with the given identity.
     *
     * @see Identity
     **/
    [\\"cpp:const\\", \\"swift:nonnull\\"] Object* createDirectProxy(Identity id);

    /**
     * Create an indirect proxy for the object with the given identity. If this
     * object adapter is configured with an adapter id, the return value refers
     * to the adapter id. Otherwise, the return value contains only the object
     * identity.
     *
     * @param id The object's identity.
     *
     * @return A proxy for the object with the given identity.
     *
     * @see Identity
     **/
    [\\"cpp:const\\", \\"swift:nonnull\\"] Object* createIndirectProxy(Identity id);

    /**
     * Set an Ice locator for this object adapter. By doing so, the object
     * adapter will register itself with the locator registry when it is
     * activated for the first time. Furthermore, the proxies created by this
     * object adapter will contain the adapter identifier instead of its
     * endpoints. The adapter identifier must be configured using the AdapterId
     * property.
     *
     * @param loc The locator used by this object adapter.
     *
     * @see #createDirectProxy
     * @see Locator
     * @see LocatorRegistry
     **/
    void setLocator(Locator* loc);

    /**
     * Get the Ice locator used by this object adapter.
     *
     * @return  The locator used by this object adapter, or null if no locator
     * is used by this object adapter.
     *
     * @see Locator
     * @see #setLocator
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] Locator* getLocator();

    /**
     * Get the set of endpoints configured with this object adapter.
     *
     * @return The set of endpoints.
     *
     * @see Endpoint
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"] EndpointSeq getEndpoints();

    /**
     * Refresh the set of published endpoints. The run time re-reads the
     * PublishedEndpoints property if it is set and re-reads the list of local
     * interfaces if the adapter is configured to listen on all endpoints. This
     * operation is useful to refresh the endpoint information that is published
     * in the proxies that are created by an object adapter if the network
     * interfaces used by a host changes.
     **/
    [\\"js:async\\"] void refreshPublishedEndpoints();

    /**
     * Get the set of endpoints that proxies created by this object adapter will
     * contain.
     *
     * @return The set of published endpoints.
     *
     * @see #refreshPublishedEndpoints
     * @see Endpoint
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"]
    EndpointSeq getPublishedEndpoints();

    /**
     * Set of the endpoints that proxies created by this object adapter will
     * contain.
     *
     * @param newEndpoints The new set of endpoints that the object adapter will
     * embed in proxies.
     *
     * @see #refreshPublishedEndpoints
     * @see Endpoint
     **/
    void setPublishedEndpoints(EndpointSeq newEndpoints);

  };

};
"
`;

exports[`Built-in slices Ice/ObjectAdapterF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local interface ObjectAdapter;

};
"
`;

exports[`Built-in slices Ice/ObjectFactory.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A factory for objects. Object factories are used when receiving \\"objects by
   * value\\". An object factory must be implemented by the application writer and
   * registered with the communicator.
   **/
  [\\"deprecate:ObjectFactory has been deprecated, use ValueFactory instead.\\"]
  local interface ObjectFactory {
    /**
     * Create a new object for a given object type. The type is the absolute
     * Slice type id, i.e., the id relative to the unnamed top-level Slice
     * module. For example, the absolute Slice type id for interfaces of type
     * <code>Bar</code> in the module
     * <code>Foo</code> is <code>\\"::Foo::Bar\\"</code>.
     *
     * <p class=\\"Note\\">The leading \\"<code>::</code>\\" is required.
     *
     * @param type The object type.
     *
     * @return The object created for the given type, or nil if the factory is
     * unable to create the object.
     **/
    Value create(string type);

    /**
     * Called when the factory is removed from the communicator, or if the
     * communicator is destroyed.
     *
     * @see Communicator#destroy
     **/
    void destroy();
  };

};
"
`;

exports[`Built-in slices Ice/Plugin.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/LoggerF.ice>
#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A communicator plug-in. A plug-in generally adds a feature to a
   * communicator, such as support for a protocol.
   *
   * The communicator loads its plug-ins in two stages: the first stage creates
   * the plug-ins, and the second stage invokes {@link Plugin#initialize} on
   * each one.
   **/
  local interface Plugin {
    /**
     * Perform any necessary initialization steps.
     **/
    void initialize();

    /**
     * Called when the communicator is being destroyed.
     **/
    void destroy();
  };

  /**
   * Each communicator has a plug-in manager to administer the set of plug-ins.
   **/
  local interface PluginManager {
    /**
     * Initialize the configured plug-ins. The communicator automatically
     * initializes the plug-ins by default, but an application may need to
     * interact directly with a plug-in prior to initialization. In this case,
     * the application must set
     * <code>Ice.InitPlugins=0</code> and then invoke {@link #initializePlugins}
     * manually. The plug-ins are initialized in the order in which they are loaded.
     * If a plug-in raises an exception during initialization, the communicator invokes
     * destroy on the plug-ins that have already been initialized.
     *
     * @throws InitializationException Raised if the plug-ins have already been
     * initialized.
     **/
    void initializePlugins();

    /**
     * Get a list of plugins installed.
     *
     * @return The names of the plugins installed.
     *
     * @see #getPlugin
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"] StringSeq getPlugins();

    /**
     * Obtain a plug-in by name.
     *
     * @param name The plug-in's name.
     *
     * @return The plug-in.
     *
     * @throws NotRegisteredException Raised if no plug-in is found with the
     * given name.
     **/
    Plugin getPlugin(string name);

    /**
     * Install a new plug-in.
     *
     * @param name The plug-in's name.
     *
     * @param pi The plug-in.
     *
     * @throws AlreadyRegisteredException Raised if a plug-in already exists
     * with the given name.
     **/
    void addPlugin(string name, Plugin pi);

    /**
     * Called when the communicator is being destroyed.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"] void destroy();
  };

};
"
`;

exports[`Built-in slices Ice/PluginF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local interface Plugin;
  local interface PluginManager;

};
"
`;

exports[`Built-in slices Ice/Process.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * An administrative interface for process management. Managed servers must
   * implement this interface.
   *
   * <p class=\\"Note\\">A servant implementing this interface is a potential target
   * for denial-of-service attacks, therefore proper security precautions should
   * be taken. For example, the servant can use a UUID to make its identity
   * harder to guess, and be registered in an object adapter with a secured
   * endpoint.
   **/
  interface Process {
    /**
     * Initiate a graceful shut-down.
     *
     * @see Communicator#shutdown
     **/
    void shutdown();

    /**
     * Write a message on the process' stdout or stderr.
     *
     * @param message The message.
     *
     * @param fd 1 for stdout, 2 for stderr.
     **/
    void writeMessage(string message, int fd);
  };

};
"
`;

exports[`Built-in slices Ice/ProcessF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  interface Process;

};
"
`;

exports[`Built-in slices Ice/Properties.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/PropertiesAdmin.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A property set used to configure Ice and Ice applications. Properties are
   * key/value pairs, with both keys and values being strings. By convention,
   * property keys should have the form
   * <em>application-name</em>\\\\[.<em>category</em>\\\\[.<em>sub-category</em>]].<em>name</em>.
   **/
  local interface Properties {
    /**
     * Get a property by key. If the property is not set, an empty string is
     * returned.
     *
     * @param key The property key.
     *
     * @return The property value.
     *
     * @see #setProperty
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"] string getProperty(string key);

    /**
     * Get a property by key. If the property is not set, the given default
     * value is returned.
     *
     * @param key The property key.
     *
     * @param value The default value to use if the property does not exist.
     *
     * @return The property value or the default value.
     *
     * @see #setProperty
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"]
    string getPropertyWithDefault(string key, string value);

    /**
     * Get a property as an integer. If the property is not set, 0 is returned.
     *
     * @param key The property key.
     *
     * @return The property value interpreted as an integer.
     *
     * @see #setProperty
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"] int getPropertyAsInt(string key);

    /**
     * Get a property as an integer. If the property is not set, the given
     * default value is returned.
     *
     * @param key The property key.
     *
     * @param value The default value to use if the property does not exist.
     *
     * @return The property value interpreted as an integer, or the default
     * value.
     *
     * @see #setProperty
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"]
    int getPropertyAsIntWithDefault(string key, int value);

    /**
     * Get a property as a list of strings. The strings must be separated by
     * whitespace or comma. If the property is not set, an empty list is
     * returned. The strings in the list can contain whitespace and commas if
     * they are enclosed in single or double quotes. If quotes are mismatched,
     * an empty list is returned. Within single quotes or double quotes, you can
     * escape the quote in question with \\\\, e.g. O'Reilly can be written as
     * O'Reilly, \\"O'Reilly\\" or 'O\\\\'Reilly'.
     *
     * @param key The property key.
     *
     * @return The property value interpreted as a list of strings.
     *
     * @see #setProperty
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"] StringSeq getPropertyAsList(string key);

    /**
     * Get a property as a list of strings.  The strings must be separated by
     * whitespace or comma. If the property is not set, the default list is
     * returned. The strings in the list can contain whitespace and commas if
     * they are enclosed in single or double quotes. If quotes are mismatched,
     * the default list is returned. Within single quotes or double quotes, you
     * can escape the quote in question with \\\\, e.g. O'Reilly can be written as
     * O'Reilly, \\"O'Reilly\\" or 'O\\\\'Reilly'.
     *
     * @param key The property key.
     *
     * @param value The default value to use if the property is not set.
     *
     * @return The property value interpreted as list of strings, or the default
     * value.
     *
     * @see #setProperty
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"]
    StringSeq getPropertyAsListWithDefault(string key, StringSeq value);

    /**
     * Get all properties whose keys begins with
     * <em>prefix</em>. If
     * <em>prefix</em> is an empty string, then all properties are returned.
     *
     * @param prefix The prefix to search for (empty string if none).
     * @return The matching property set.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"]
    PropertyDict getPropertiesForPrefix(string prefix);

    /**
     * Set a property. To unset a property, set it to the empty string.
     *
     * @param key The property key.
     * @param value The property value.
     *
     * @see #getProperty
     **/
    [\\"swift:noexcept\\"] void setProperty(string key, string value);

    /**
     * Get a sequence of command-line options that is equivalent to this
     * property set. Each element of the returned sequence is a command-line
     * option of the form
     * <code>--<em>key</em>=<em>value</em></code>.
     *
     * @return The command line options for this property set.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"] StringSeq getCommandLineOptions();

    /**
     * Convert a sequence of command-line options into properties. All options
     * that begin with
     * <code>--<em>prefix</em>.</code> are converted into properties. If the prefix
     * is empty, all options that begin with <code>--</code> are converted to properties.
     *
     * @param prefix The property prefix, or an empty string to convert all
     * options starting with <code>--</code>.
     *
     * @param options The command-line options.
     *
     * @return The command-line options that do not start with the specified
     * prefix, in their original order.
     **/
    StringSeq parseCommandLineOptions(string prefix, StringSeq options);

    /**
     * Convert a sequence of command-line options into properties. All options
     * that begin with one of the following prefixes are converted into
     * properties: <code>--Ice</code>, <code>--IceBox</code>,
     * <code>--IceGrid</code>,
     * <code>--IcePatch2</code>, <code>--IceSSL</code>, <code>--IceStorm</code>,
     * <code>--Freeze</code>, and <code>--Glacier2</code>.
     *
     * @param options The command-line options.
     *
     * @return The command-line options that do not start with one of the listed
     * prefixes, in their original order.
     **/
    StringSeq parseIceCommandLineOptions(StringSeq options);

    /**
     * Load properties from a file.
     *
     * @param file The property file.
     **/
    void load(string file);
    /**
     * Create a copy of this property set.
     *
     * @return A copy of this property set.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\", \\"swift:nonnull\\"] Properties clone();
  };

};
"
`;

exports[`Built-in slices Ice/PropertiesAdmin.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A simple collection of properties, represented as a dictionary of key/value
   * pairs. Both key and value are strings.
   *
   * @see Properties#getPropertiesForPrefix
   **/
  dictionary<string, string> PropertyDict;

  /**
   * The PropertiesAdmin interface provides remote access to the properties of a
   * communicator.
   **/
  interface PropertiesAdmin {
    /**
     * Get a property by key. If the property is not set, an empty string is
     * returned.
     *
     * @param key The property key.
     *
     * @return The property value.
     **/
    string getProperty(string key);

    /**
     * Get all properties whose keys begin with <em>prefix</em>. If
     * <em>prefix</em> is an empty string then all properties are returned.
     *
     * @param prefix The prefix to search for (empty string if none).
     * @return The matching property set.
     **/
    [\\"java:type:java.util.TreeMap<String, String>\\"]
    PropertyDict getPropertiesForPrefix(string prefix);

    /**
     * Update the communicator's properties with the given property set.
     *
     * @param newProperties Properties to be added, changed, or removed. If an
     * entry in <em>newProperties</em> matches the name of an existing property,
     * that property's value is replaced with the new value. If the new value is
     * an empty string, the property is removed. Any existing properties that
     * are not modified or removed by the entries in newProperties are retained
     * with their original values.
     **/
    void setProperties(PropertyDict newProperties);
  };

};
"
`;

exports[`Built-in slices Ice/PropertiesF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local interface Properties;
  interface PropertiesAdmin;

};
"
`;

exports[`Built-in slices Ice/RemoteLogger.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:list\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * An enumeration representing the different types of log messages.
   **/
  enum LogMessageType {
    /**
     * The {@link Logger} received a print message.
     **/
    PrintMessage,

    /**
     * The {@link Logger} received a trace message.
     **/
    TraceMessage,

    /**
     * The {@link Logger} received a warning message.
     **/
    WarningMessage,

    /**
     * The {@link Logger} received an error message.
     **/
    ErrorMessage,
  };

  /**
   * A sequence of {@link LogMessageType}
   **/
  sequence<LogMessageType> LogMessageTypeSeq;

  /**
   * A complete log message.
   **/
  struct LogMessage {
    /**
     * The type of message sent to the {@link Logger}.
     **/
    LogMessageType type;

    /**
     * The date and time when the {@link Logger} received this message,
     * expressed as the number of microseconds since the Unix Epoch (00:00:00
     * UTC on 1 January 1970)
     **/
    long timestamp;

    /**
     * For a message of type trace, the trace category of this log message;
     * otherwise, the empty string.
     **/
    string traceCategory;

    /**
     * The log message itself.
     **/
    string message;
  };

  /**
   * A sequence of {@link LogMessage}.
   **/
  [\\"cpp:type:std::list<LogMessage>\\"] sequence<LogMessage> LogMessageSeq;

  /**
   * The Ice remote logger interface. An application can implement a
   * RemoteLogger to receive the log messages sent to the local {@link Logger}
   * of another Ice application.
   **/
  interface RemoteLogger {
    /**
     * init is called by attachRemoteLogger when a RemoteLogger proxy is
     * attached.
     *
     * @param prefix The prefix of the associated local Logger.
     *
     * @param logMessages Old log messages generated before \\"now\\".
     **/
    void init(string prefix, LogMessageSeq logMessages);

    /**
     * Log a LogMessage. Note that log may be called by LoggerAdmin before init.
     *
     * @param message The message to log.
     **/
    void log(LogMessage message);
  };

  /**
   * Thrown when the provided RemoteLogger was previously attached to a
   * LoggerAdmin.
   **/
  exception RemoteLoggerAlreadyAttachedException {};

  /**
   * The interface of the admin object that allows an Ice application the attach
   * its
   * {@link RemoteLogger} to the {@link Logger} of this admin object's Ice communicator.
   **/
  interface LoggerAdmin {
    /**
     * Attaches a RemoteLogger object to the local logger. attachRemoteLogger
     * calls init on the provided RemoteLogger proxy.
     *
     * @param prx A proxy to the remote logger.
     *
     * @param messageTypes The list of message types that the remote logger
     * wishes to receive. An empty list means no filtering (send all message
     * types).
     *
     * @param traceCategories The categories of traces that the remote logger
     * wishes to receive. This parameter is ignored if messageTypes is not empty
     * and does not include trace. An empty list means no filtering (send all
     * trace categories).
     *
     * @param messageMax The maximum number of log messages (of all types) to be
     * provided to init. A negative value requests all messages available.
     *
     * @throws RemoteLoggerAlreadyAttachedException Raised if this remote logger
     * is already attached to this admin object.
     **/
    void attachRemoteLogger(
      RemoteLogger* prx,
      LogMessageTypeSeq messageTypes,
      StringSeq traceCategories,
      int messageMax
    )
      throws RemoteLoggerAlreadyAttachedException;

    /**
     * Detaches a RemoteLogger object from the local logger.
     *
     * @param prx A proxy to the remote logger.
     *
     * @return True if the provided remote logger proxy was detached, and false
     * otherwise.
     **/
    bool detachRemoteLogger(RemoteLogger* prx);

    /**
     * Retrieves log messages recently logged.
     *
     * @param messageTypes The list of message types that the caller wishes to
     * receive. An empty list means no filtering (send all message types).
     *
     * @param traceCategories The categories of traces that caller wish to
     * receive. This parameter is ignored if messageTypes is not empty and does
     * not include trace. An empty list means no filtering (send all trace
     * categories).
     *
     * @param messageMax The maximum number of log messages (of all types) to be
     * returned. A negative value requests all messages available.
     *
     * @param prefix The prefix of the associated local logger.
     *
     * @return The Log messages.
     **/
    LogMessageSeq getLog(
      LogMessageTypeSeq messageTypes,
      StringSeq traceCategories,
      int messageMax,
      out string prefix
    );
  };

};
"
`;

exports[`Built-in slices Ice/Router.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * The Ice router interface. Routers can be set either globally with
   * {@link Communicator#setDefaultRouter}, or with <code>ice_router</code> on specific
   * proxies.
   **/
  interface Router {
    /**
     * Get the router's client proxy, i.e., the proxy to use for forwarding
     * requests from the client to the router.
     *
     * If a null proxy is returned, the client will forward requests to the
     * router's endpoints.
     *
     * @param hasRoutingTable Indicates whether or not the router supports a
     * routing table. If it is supported, the Ice runtime will call addProxies
     * to populate the routing table. This out parameter is only supported
     * starting with Ice 3.7. The Ice runtime assumes the router has a routing
     * table if the optional is not set.
     *
     * @return The router's client proxy.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Object* getClientProxy(out optional(1) bool hasRoutingTable);

    /**
     * Get the router's server proxy, i.e., the proxy to use for forwarding
     * requests from the server to the router.
     *
     * @return The router's server proxy.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent Object* getServerProxy();

    /**
     * Add new proxy information to the router's routing table.
     *
     * @param proxies The proxies to add.
     *
     * @return Proxies discarded by the router.
     **/
    idempotent ObjectProxySeq addProxies(ObjectProxySeq proxies);
  };

  /**
   * This inferface should be implemented by services implementing the
   * Ice::Router interface. It should be advertised through an Ice object with
   * the identity \`Ice/RouterFinder'. This allows clients to retrieve the router
   * proxy with just the endpoint information of the service.
   **/
  interface RouterFinder {
    /**
     * Get the router proxy implemented by the process hosting this finder
     * object. The proxy might point to several replicas.
     *
     * @return The router proxy.
     **/
    Router* getRouter();
  };

};
"
`;

exports[`Built-in slices Ice/RouterF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  interface Router;

};
"
`;

exports[`Built-in slices Ice/ServantLocator.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/ObjectAdapterF.ice>
#include <Ice/Current.ice>

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A servant locator is called by an object adapter to locate a servant that
   * is not found in its active servant map.
   *
   * @see ObjectAdapter
   * @see ObjectAdapter#addServantLocator
   * @see ObjectAdapter#findServantLocator
   **/
  local interface ServantLocator {
    /**
     * Called before a request is dispatched if a servant cannot be found in the
     * object adapter's active servant map. Note that the object adapter does
     * not automatically insert the returned servant into its active servant
     * map. This must be done by the servant locator implementation, if this is
     * desired.
     *
     * <code>locate</code> can throw any user exception. If it does, that
     * exception is marshaled back to the client. If the Slice definition for
     * the corresponding operation includes that user exception, the client
     * receives that user exception; otherwise, the client receives
     * {@link UnknownUserException}.
     *
     * If <code>locate</code> throws any exception, the Ice run time does
     * <em>not</em> call <code>finished</code>.
     *
     * <p class=\\"Note\\">If you call <code>locate</code> from your own code, you
     * must also call <code>finished</code> when you have finished using the
     * servant, provided that <code>locate</code> returned a non-null servant;
     * otherwise, you will get undefined behavior if you use servant locators
     * such as the Freeze Evictor.
     *
     * @param curr Information about the current operation for which a servant
     * is required.
     *
     * @param cookie A \\"cookie\\" that will be passed to <code>finished</code>.
     *
     * @return The located servant, or null if no suitable servant has been
     * found.
     *
     * @throws UserException The implementation can raise a UserException and
     * the run time will marshal it as the result of the invocation.
     *
     * @see ObjectAdapter
     * @see Current
     * @see #finished
     **/
    [\\"java:UserException\\"] Object locate(Current curr, out LocalObject cookie);

    /**
     * Called by the object adapter after a request has been made. This
     * operation is only called if <code>locate</code> was called prior to the
     * request and returned a non-null servant. This operation can be used for
     * cleanup purposes after a request.
     *
     * <code>finished</code> can throw any user exception. If it does, that
     * exception is marshaled back to the client. If the Slice definition for
     * the corresponding operation includes that user exception, the client
     * receives that user exception; otherwise, the client receives
     * {@link UnknownUserException}.
     *
     * If both the operation and <code>finished</code> throw an exception, the
     * exception thrown by <code>finished</code> is marshaled back to the
     * client.
     *
     * @param curr Information about the current operation call for which a
     * servant was located by <code>locate</code>.
     *
     * @param servant The servant that was returned by <code>locate</code>.
     *
     * @param cookie The cookie that was returned by <code>locate</code>.
     *
     * @throws UserException The implementation can raise a UserException and
     * the run time will marshal it as the result of the invocation.
     *
     * @see ObjectAdapter
     * @see Current
     * @see #locate
     **/
    [\\"java:UserException\\"]
    void finished(
      Current curr,
      [\\"swift:nonnull\\"] Object servant,
      LocalObject cookie
    );

    /**
     * Called when the object adapter in which this servant locator is installed
     * is destroyed.
     *
     * @param category Indicates for which category the servant locator is being
     * deactivated.
     *
     * @see ObjectAdapter#destroy
     * @see Communicator#shutdown
     * @see Communicator#destroy
     **/
    [\\"swift:noexcept\\"] void deactivate(string category);
  };

};
"
`;

exports[`Built-in slices Ice/ServantLocatorF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  local interface ServantLocator;

};
"
`;

exports[`Built-in slices Ice/SliceChecksumDict.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A mapping from type IDs to Slice checksums. The dictionary allows
   * verification at run time that client and server use matching Slice
   * definitions.
   **/
  dictionary<string, string> SliceChecksumDict;

};
"
`;

exports[`Built-in slices Ice/ValueFactory.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A factory for values. Value factories are used in several places, such as
   * when Ice receives a class instance and when Freeze restores a persistent
   * value. Value factories must be implemented by the application writer and
   * registered with the communicator.
   **/
  [\\"delegate\\"]
  local interface ValueFactory {
    /**
     * Create a new value for a given value type. The type is the absolute Slice
     * type id, i.e., the id relative to the unnamed top-level Slice module. For
     * example, the absolute Slice type id for an interface <code>Bar</code> in
     * the module
     * <code>Foo</code> is <code>\\"::Foo::Bar\\"</code>.
     *
     * Note that the leading \\"<code>::</code>\\" is required.
     *
     * @param type The value type.
     *
     * @return The value created for the given type, or nil if the factory is
     * unable to create the value.
     **/
    [\\"swift:noexcept\\"] Value create(string type);
  };

  /**
   * A value factory manager maintains a collection of value factories. An
   * application can supply a custom implementation during communicator
   * initialization, otherwise Ice provides a default implementation.
   *
   * @see ValueFactory
   **/
  local interface ValueFactoryManager {
    /**
     * Add a value factory. Attempting to add a factory with an id for which a
     * factory is already registered throws AlreadyRegisteredException.
     *
     * When unmarshaling an Ice value, the Ice run time reads the most-derived
     * type id off the wire and attempts to create an instance of the type using
     * a factory. If no instance is created, either because no factory was
     * found, or because all factories returned nil, the behavior of the Ice run
     * time depends on the format with which the value was marshaled:
     *
     * If the value uses the \\"sliced\\" format, Ice ascends the class hierarchy
     * until it finds a type that is recognized by a factory, or it reaches the
     * least-derived type. If no factory is found that can create an instance,
     * the run time throws NoValueFactoryException.
     *
     * If the value uses the \\"compact\\" format, Ice immediately raises
     * NoValueFactoryException.
     *
     * The following order is used to locate a factory for a type:
     *
     * <ol>
     *
     * <li>The Ice run-time looks for a factory registered specifically for the
     * type.</li>
     *
     * <li>If no instance has been created, the Ice run-time looks for the
     * default factory, which is registered with an empty type id.
     * </li>
     *
     * <li>If no instance has been created by any of the preceding steps, the
     * Ice run-time looks for a factory that may have been statically generated
     * by the language mapping for non-abstract classes.
     * </li>
     *
     * </ol>
     *
     * @param factory The factory to add.
     *
     * @param id The type id for which the factory can create instances, or an
     * empty string for the default factory.
     **/
    void add(
      [\\"swift:nonnull\\"] ValueFactory factory,
      [\\"objc:param:sliceId\\"] string id
    );

    /**
     * Find an value factory registered with this communicator.
     *
     * @param id The type id for which the factory can create instances, or an
     * empty string for the default factory.
     *
     * @return The value factory, or null if no value factory was found for the
     * given id.
     **/
    [\\"cpp:const\\", \\"cpp:noexcept\\", \\"swift:noexcept\\"]
    ValueFactory find(string id);
  };
};
"
`;

exports[`Built-in slices Ice/Version.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICE_API\\"]]
[[\\"cpp:doxygen:include:Ice/Ice.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICE_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:Ice\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICE\\"]
module Ice {
  /**
   * A version structure for the protocol version.
   **/
  struct ProtocolVersion {
    byte major;
    byte minor;
  };

  /**
   * A version structure for the encoding version.
   **/
  struct EncodingVersion {
    byte major;
    byte minor;
  };

};
"
`;

exports[`Built-in slices IceBT/ConnectionInfo.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEBT_API\\"]]
[[\\"cpp:doxygen:include:IceBT/IceBT.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceBT\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Connection.ice>

[\\"objc:prefix:ICEBT\\"]
module IceBT {
  /**
   * Provides access to the details of a Bluetooth connection.
   **/
  local class ConnectionInfo extends Ice::ConnectionInfo {
    string localAddress = \\"\\";

    int localChannel = -1;

    string remoteAddress = \\"\\";

    int remoteChannel = -1;

    string uuid = \\"\\";

    int rcvSize = 0;

    int sndSize = 0;
  };

};
"
`;

exports[`Built-in slices IceBT/EndpointInfo.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEBT_API\\"]]
[[\\"cpp:doxygen:include:IceBT/IceBT.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceBT\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Endpoint.ice>

/**
 * IceBT provides a Bluetooth transport for Ice.
 **/
[\\"objc:prefix:ICEBT\\", \\"swift:module:Ice:SSL\\"]
module IceBT {
  /**
   * Provides access to Bluetooth endpoint information.
   **/
  local class EndpointInfo extends Ice::EndpointInfo {
    /**
     * The address configured with the endpoint.
     **/
    string addr;

    /**
     * The UUID configured with the endpoint.
     **/
    string uuid;
  };

};
"
`;

exports[`Built-in slices IceBT/Types.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEBT_API\\"]]
[[\\"cpp:doxygen:include:IceBT/IceBT.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceBT\\"]]
[[\\"java:package:com.zeroc\\"]]

/**
 * IceBT provides a Bluetooth transport for Ice.
 **/
[\\"objc:prefix:ICEBT\\"]
module IceBT {
  /**
   * Indicates a failure in the Bluetooth plug-in.
   **/
  [\\"cpp:ice_print\\"]
  local exception BluetoothException {
    string reason;
  };

};
"
`;

exports[`Built-in slices IceBox/IceBox.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEBOX_API\\"]]
[[\\"cpp:doxygen:include:IceBox/IceBox.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceBox/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceBox\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>
#include <Ice/CommunicatorF.ice>
#include <Ice/PropertiesF.ice>
#include <Ice/SliceChecksumDict.ice>

/**
 * IceBox is an application server specifically for Ice applications. IceBox can
 * easily run and administer Ice services that are dynamically loaded as a DLL,
 * shared library, or Java class.
 **/
module IceBox {
  /**
   * This exception is a general failure notification. It is thrown for errors
   * such as a service encountering an error during initialization, or the
   * service manager being unable to load a service executable.
   **/
  [\\"cpp:ice_print\\"]
  local exception FailureException {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception is thrown if an attempt is made to start an already-started
   * service.
   **/
  exception AlreadyStartedException {};

  /**
   * This exception is thrown if an attempt is made to stop an already-stopped
   * service.
   **/
  exception AlreadyStoppedException {};

  /**
   * This exception is thrown if a service name does not refer to an existing
   * service.
   **/
  exception NoSuchServiceException {};

  /**
   * An application service managed by a {@link ServiceManager}.
   **/
  local interface Service {
    /**
     * Start the service. The given communicator is created by the
     * {@link ServiceManager} for use by the service. This communicator may also
     * be used by other services, depending on the service configuration.
     *
     * <p class=\\"Note\\">The {@link ServiceManager} owns this communicator, and is
     * responsible for destroying it.
     *
     * @param name The service's name, as determined by the configuration.
     *
     * @param communicator A communicator for use by the service.
     *
     * @param args The service arguments that were not converted into
     * properties.
     *
     * @throws FailureException Raised if {@link #start} failed.
     **/
    void start(
      string name,
      Ice::Communicator communicator,
      Ice::StringSeq args
    );

    /**
     * Stop the service.
     **/
    void stop();
  };

  /**
   * An Observer interface implemented by admin clients interested in the status
   * of services
   *
   * @see ServiceManager
   **/
  interface ServiceObserver {
    void servicesStarted(Ice::StringSeq services);
    void servicesStopped(Ice::StringSeq services);
  };

  /**
   * Administers a set of {@link Service} instances.
   *
   * @see Service
   **/
  interface ServiceManager {
    /**
     * Returns the checksums for the IceBox Slice definitions.
     *
     * @return A dictionary mapping Slice type ids to their checksums.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Ice::SliceChecksumDict getSliceChecksums();

    /**
     * Start an individual service.
     *
     * @param service The service name.
     *
     * @throws AlreadyStartedException If the service is already running.
     * @throws NoSuchServiceException If no service could be found with the given
     * name.
     **/
    void startService(string service)
      throws AlreadyStartedException, NoSuchServiceException;

    /**
     * Stop an individual service.
     *
     * @param service The service name.
     *
     * @throws AlreadyStoppedException If the service is already stopped.
     * @throws NoSuchServiceException If no service could be found with the given
     * name.
     **/
    void stopService(string service)
      throws AlreadyStoppedException, NoSuchServiceException;

    /**
     * Registers a new observer with the ServiceManager.
     *
     * @param observer The new observer
     **/
    void addObserver(ServiceObserver* observer);

    /**
     * Shut down all services. This causes stop to be invoked on all configured
     * services.
     **/
    void shutdown();
  };

};
"
`;

exports[`Built-in slices IceDiscovery/IceDiscovery.ice 1`] = `
"#pragma once

[[\\"cpp:doxygen:include:IceDiscovery/IceDiscovery.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceDiscovery\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Identity.ice>

module IceDiscovery {
  interface LookupReply {
    void foundObjectById(Ice::Identity id, Object* prx);

    void foundAdapterById(string id, Object* prx, bool isReplicaGroup);
  };

  interface Lookup {
    idempotent void findObjectById(
      string domainId,
      Ice::Identity id,
      LookupReply* reply
    );

    idempotent void findAdapterById(
      string domainId,
      string id,
      LookupReply* reply
    );
  };

};
"
`;

exports[`Built-in slices IceGrid/Admin.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEGRID_API\\"]]
[[\\"cpp:doxygen:include:IceGrid/IceGrid.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceGrid/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICEGRID_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceGrid\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Identity.ice>
#include <Ice/BuiltinSequences.ice>
#include <Ice/Properties.ice>
#include <Ice/SliceChecksumDict.ice>
#include <Glacier2/Session.ice>
#include <IceGrid/Exception.ice>
#include <IceGrid/Descriptor.ice>

[\\"objc:prefix:ICEGRID\\"]
module IceGrid {
  /**
   * An enumeration representing the state of the server.
   **/
  enum ServerState {
    /**
     * The server is not running.
     **/
    Inactive,

    /**
     * The server is being activated and will change to the active state when
     * the registered server object adapters are activated or to the activation
     * timed out state if the activation timeout expires.
     **/
    Activating,

    /**
     * The activation timed out state indicates that the server activation timed
     * out.
     **/
    ActivationTimedOut,

    /**
     * The server is running.
     **/
    Active,

    /**
     * The server is being deactivated.
     **/
    Deactivating,

    /**
     * The server is being destroyed.
     **/
    Destroying,

    /**
     * The server is destroyed.
     **/
    Destroyed,
  };

  /**
   * A dictionary of proxies.
   **/
  dictionary<string, Object*> StringObjectProxyDict;

  /**
   * Information about an Ice object.
   **/
  [\\"cpp:comparable\\"]
  struct ObjectInfo {
    /**
     * The proxy of the object.
     **/
    Object* proxy;

    /**
     * The type of the object.
     **/
    string type;
  };

  /**
   * A sequence of object information structures.
   **/
  sequence<ObjectInfo> ObjectInfoSeq;

  /**
   * Information about an adapter registered with the IceGrid registry.
   **/
  [\\"cpp:comparable\\"]
  struct AdapterInfo {
    /**
     * The id of the adapter.
     **/
    string id;

    /**
     * A dummy direct proxy that contains the adapter endpoints.
     **/
    Object* proxy;

    /**
     * The replica group id of the object adapter, or empty if the adapter
     * doesn't belong to a replica group.
     **/
    string replicaGroupId;
  };

  /**
   * A sequence of adapter information structures.
   **/
  sequence<AdapterInfo> AdapterInfoSeq;

  /**
   * Information about a server managed by an IceGrid node.
   **/
  struct ServerInfo {
    /**
     * The server application.
     **/
    string application;

    /**
     * The application uuid.
     **/
    string uuid;

    /**
     * The application revision.
     **/
    int revision;

    /**
     * The server node.
     **/
    string node;

    /**
     * The server descriptor.
     **/
    ServerDescriptor descriptor;

    /**
     * The id of the session which allocated the server.
     **/
    string sessionId;
  };

  /**
   * Information about an IceGrid node.
   **/
  struct NodeInfo {
    /**
     * The name of the node.
     **/
    string name;

    /**
     * The operating system name.
     **/
    string os;

    /**
     * The network name of the host running this node (as defined in uname()).
     **/
    string hostname;

    /**
     * The operation system release level (as defined in uname()).
     **/
    string release;

    /**
     * The operation system version (as defined in uname()).
     **/
    string version;

    /**
     * The machine hardware type (as defined in uname()).
     **/
    string machine;

    /**
     * The number of processor threads on the node. For example, nProcessors is
     * 8 on a computer with a single quad-core processor and two HT threads per
     * core.
     **/
    int nProcessors;

    /**
     * The path to the node data directory.
     **/
    string dataDir;
  };

  /**
   * Information about an IceGrid registry replica.
   **/
  struct RegistryInfo {
    /**
     * The name of the registry.
     **/
    string name;

    /**
     * The network name of the host running this registry (as defined in
     * uname()).
     **/
    string hostname;
  };

  /**
   * A sequence of {@link RegistryInfo} structures.
   **/
  sequence<RegistryInfo> RegistryInfoSeq;

  /**
   * Information about the load of a node.
   **/
  struct LoadInfo {
    float avg1;

    float avg5;

    float avg15;
  };

  /**
   * Information about an IceGrid application.
   **/
  struct ApplicationInfo {
    string uuid;

    long createTime;

    string createUser;

    long updateTime;

    string updateUser;

    int revision;

    ApplicationDescriptor descriptor;
  };

  /**
   * A sequence of {@link ApplicationInfo} structures.
   **/
  [\\"java:type:java.util.LinkedList<ApplicationInfo>\\"]
  sequence<ApplicationInfo> ApplicationInfoSeq;

  /**
   * Information about updates to an IceGrid application.
   **/
  struct ApplicationUpdateInfo {
    long updateTime;

    string updateUser;

    int revision;

    ApplicationUpdateDescriptor descriptor;
  };

  /**
   * The IceGrid administrative interface.
   * <p class=\\"Warning\\">Allowing access to this interface is a security risk! Please
   * see the IceGrid documentation for further information.
   **/
  interface Admin {
    /**
     * Add an application to IceGrid.
     *
     * @param descriptor The application descriptor.
     *
     * @throws AccessDeniedException Raised if the session doesn't hold the
     * exclusive lock or if another session is holding the lock.
     *
     * @throws DeploymentException Raised if application deployment failed.
     **/
    void addApplication(ApplicationDescriptor descriptor)
      throws AccessDeniedException, DeploymentException;

    /**
     * Synchronize a deployed application with the given application descriptor.
     * This operation will replace the current descriptor with this new
     * descriptor.
     *
     * @param descriptor The application descriptor.
     *
     * @throws AccessDeniedException Raised if the session doesn't hold the
     * exclusive lock or if another session is holding the lock.
     *
     * @throws DeploymentException Raised if application deployment failed.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     **/
    void syncApplication(ApplicationDescriptor descriptor)
      throws
        AccessDeniedException,
        DeploymentException,
        ApplicationNotExistException;

    /**
     * Update a deployed application with the given update application
     * descriptor.
     *
     * @param descriptor The update descriptor.
     *
     * @throws AccessDeniedException Raised if the session doesn't hold the
     * exclusive lock or if another session is holding the lock.
     *
     * @throws DeploymentException Raised if application deployment failed.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     **/
    void updateApplication(ApplicationUpdateDescriptor descriptor)
      throws
        AccessDeniedException,
        DeploymentException,
        ApplicationNotExistException;

    /**
     * Synchronize a deployed application with the given application descriptor.
     * This operation will replace the current descriptor with this new
     * descriptor only if no server restarts are necessary for the update of the
     * application. If some servers need to be restarted, the synchronization is
     * rejected with a DeploymentException.
     *
     * @param descriptor The application descriptor.
     *
     * @throws AccessDeniedException Raised if the session doesn't hold the
     * exclusive lock or if another session is holding the lock.
     *
     * @throws DeploymentException Raised if application deployment failed.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     **/
    void syncApplicationWithoutRestart(ApplicationDescriptor descriptor)
      throws
        AccessDeniedException,
        DeploymentException,
        ApplicationNotExistException;

    /**
     * Update a deployed application with the given update application
     * descriptor only if no server restarts are necessary for the update of the
     * application. If some servers need to be restarted, the synchronization is
     * rejected with a DeploymentException.
     *
     * @param descriptor The update descriptor.
     *
     * @throws AccessDeniedException Raised if the session doesn't hold the
     * exclusive lock or if another session is holding the lock.
     *
     * @throws DeploymentException Raised if application deployment failed.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     **/
    void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor)
      throws
        AccessDeniedException,
        DeploymentException,
        ApplicationNotExistException;

    /**
     * Remove an application from IceGrid.
     *
     * @param name The application name.
     *
     * @throws AccessDeniedException Raised if the session doesn't hold the
     * exclusive lock or if another session is holding the lock.
     *
     * @throws DeploymentException Raised if application deployment failed.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     **/
    void removeApplication(string name)
      throws
        AccessDeniedException,
        DeploymentException,
        ApplicationNotExistException;

    /**
     * Instantiate a server template from an application on the given node.
     *
     * @param application The application name.
     *
     * @param node The name of the node where the server will be deployed.
     *
     * @param desc The descriptor of the server instance to deploy.
     *
     * @throws AccessDeniedException Raised if the session doesn't hold the
     * exclusive lock or if another session is holding the lock.
     *
     * @throws DeploymentException Raised if server instantiation failed.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     **/
    void instantiateServer(
      string application,
      string node,
      ServerInstanceDescriptor desc
    )
      throws
        AccessDeniedException,
        ApplicationNotExistException,
        DeploymentException;

    /**
     * Patch the given application data.
     *
     * @param name The application name.
     *
     * @param shutdown If true, the servers depending on the data to patch will
     * be shut down if necessary.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     *
     * @throws PatchException Raised if the patch failed.
     **/
    [\\"amd\\"]
    void patchApplication(string name, bool shutdown)
      throws ApplicationNotExistException, PatchException;

    /**
     * Get an application descriptor.
     *
     * @param name The application name.
     *
     * @return The application descriptor.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ApplicationInfo getApplicationInfo(string name)
      throws ApplicationNotExistException;

    /**
     * Get the default application descriptor.
     *
     * @return The default application descriptor.
     *
     * @throws DeploymentException Raised if the default application descriptor
     * can't be accessed or is invalid.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ApplicationDescriptor getDefaultApplicationDescriptor()
      throws DeploymentException;

    /**
     * Get all the IceGrid applications currently registered.
     *
     * @return The application names.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Ice::StringSeq getAllApplicationNames();

    /**
     * Get the server information for the server with the given id.
     *
     * @param id The server id.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @return The server information.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ServerInfo getServerInfo(string id)
      throws ServerNotExistException;

    /**
     * Get a server's state.
     *
     * @param id The server id.
     *
     * @return The server state.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ServerState getServerState(string id)
      throws
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Get a server's system process id. The process id is operating system
     * dependent.
     *
     * @param id The server id.
     *
     * @return The server's process id.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent int getServerPid(string id)
      throws
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Get the category for server admin objects. You can manufacture a server
     * admin proxy from the admin proxy by changing its identity: use the server
     * ID as name and the returned category as category.
     *
     * @return The category for server admin objects.
     **/
    [\\"cpp:const\\"] idempotent string getServerAdminCategory();

    /**
     * Get a proxy to the server's admin object.
     *
     * @param id The server id.
     *
     * @return A proxy to the server's admin object
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    [\\"cpp:const\\"]
    idempotent Object* getServerAdmin(string id)
      throws
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Enable or disable a server. A disabled server can't be started on demand
     * or administratively. The enable state of the server is not persistent: if
     * the node is shut down and restarted, the server will be enabled by
     * default.
     *
     * @param id The server id.
     *
     * @param enabled True to enable the server, false to disable it.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    idempotent void enableServer(string id, bool enabled)
      throws
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Check if the server is enabled or disabled.
     *
     * @param id The server id.
     *
     * @return True if the server is enabled.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent bool isServerEnabled(string id)
      throws
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Start a server and wait for its activation.
     *
     * @param id The server id.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws ServerStartException Raised if the server couldn't be started.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    [\\"amd\\"]
    void startServer(string id)
      throws
        ServerNotExistException,
        ServerStartException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Stop a server.
     *
     * @param id The server id.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws ServerStopException Raised if the server couldn't be stopped.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    [\\"amd\\"]
    void stopServer(string id)
      throws
        ServerNotExistException,
        ServerStopException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Patch a server.
     *
     * @param id The server id.
     *
     * @param shutdown If true, servers depending on the data to patch will be
     * shut down if necessary.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     *
     * @throws PatchException Raised if the patch failed.
     **/
    [\\"amd\\"]
    void patchServer(string id, bool shutdown)
      throws
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException,
        PatchException;

    /**
     * Send signal to a server.
     *
     * @param id The server id.
     *
     * @param signal The signal, for example SIGTERM or 15.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     *
     * @throws BadSignalException Raised if the signal is not recognized by the
     * target server.
     **/
    void sendSignal(string id, string signal)
      throws
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException,
        BadSignalException;

    /**
     * Get all the server ids registered with IceGrid.
     *
     * @return The server ids.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent Ice::StringSeq getAllServerIds();

    /**
     * Get the adapter information for the replica group or adapter with the
     * given id.
     *
     * @param id The adapter id.
     *
     * @return A sequence of adapter information structures. If the given id
     * refers to an adapter, this sequence will contain only one element. If the
     * given id refers to a replica group, the sequence will contain the adapter
     * information of each member of the replica group.
     *
     * @throws AdapterNotExistException Raised if the adapter or replica group
     * doesn't exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent AdapterInfoSeq getAdapterInfo(string id)
      throws AdapterNotExistException;

    /**
     * Remove the adapter with the given id.
     *
     * @param id The adapter id.
     * @throws AdapterNotExistException Raised if the adapter doesn't exist.
     *
     * @throws DeploymentException Raised if application deployment failed.
     **/
    void removeAdapter(string id)
      throws AdapterNotExistException, DeploymentException;

    /**
     * Get all the adapter ids registered with IceGrid.
     *
     * @return The adapter ids.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent Ice::StringSeq getAllAdapterIds();

    /**
     * Add an object to the object registry. IceGrid will get the object type by
     * calling <code>ice_id</code> on the given proxy. The object must be
     * reachable.
     *
     * @param obj The object to be added to the registry.
     *
     * @throws ObjectExistsException Raised if the object is already registered.
     *
     * @throws DeploymentException Raised if the object can't be added. This
     * might be raised if the invocation on the proxy to get the object type
     * failed.
     **/
    void addObject(Object* obj)
      throws ObjectExistsException, DeploymentException;

    /**
     * Update an object in the object registry. Only objects added with this
     * interface can be updated with this operation. Objects added with
     * deployment descriptors should be updated with the deployment mechanism.
     *
     * @param obj The object to be updated to the registry.
     *
     * @throws ObjectNotRegisteredException Raised if the object isn't
     * registered with the registry.
     *
     * @throws DeploymentException Raised if the object can't be updated. This
     * might happen if the object was added with a deployment descriptor.
     **/
    void updateObject(Object* obj)
      throws ObjectNotRegisteredException, DeploymentException;

    /**
     * Add an object to the object registry and explicitly specify its type.
     *
     * @param obj The object to be added to the registry.
     *
     * @param type The object type.
     *
     * @throws ObjectExistsException Raised if the object is already registered.
     *
     * @throws DeploymentException Raised if application deployment failed.
     **/
    void addObjectWithType(Object* obj, string type)
      throws ObjectExistsException, DeploymentException;

    /**
     * Remove an object from the object registry. Only objects added with this
     * interface can be removed with this operation. Objects added with
     * deployment descriptors should be removed with the deployment mechanism.
     *
     * @param id The identity of the object to be removed from the registry.
     *
     * @throws ObjectNotRegisteredException Raised if the object isn't
     * registered with the registry.
     *
     * @throws DeploymentException Raised if the object can't be removed. This
     * might happen if the object was added with a deployment descriptor.
     **/
    void removeObject(Ice::Identity id)
      throws ObjectNotRegisteredException, DeploymentException;

    /**
     * Get the object info for the object with the given identity.
     *
     * @param id The identity of the object.
     *
     * @return The object info.
     *
     * @throws ObjectNotRegisteredException Raised if the object isn't
     * registered with the registry.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ObjectInfo getObjectInfo(Ice::Identity id)
      throws ObjectNotRegisteredException;

    /**
     * Get the object info of all the registered objects with the given type.
     *
     * @param type The type of the object.
     *
     * @return The object infos.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ObjectInfoSeq getObjectInfosByType(string type);

    /**
     * Get the object info of all the registered objects whose stringified
     * identities match the given expression.
     *
     * @param expr The expression to match against the stringified identities of
     * registered objects. The expression may contain a trailing wildcard
     * (<code>*</code>) character.
     *
     * @return All the object infos with a stringified identity matching the
     * given expression.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ObjectInfoSeq getAllObjectInfos(string expr);

    /**
     * Ping an IceGrid node to see if it is active.
     *
     * @param name The node name.
     *
     * @return true if the node ping succeeded, false otherwise.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent bool pingNode(string name) throws NodeNotExistException;

    /**
     * Get the load averages of the node.
     *
     * @param name The node name.
     *
     * @return The node load information.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent LoadInfo getNodeLoad(string name)
      throws NodeNotExistException, NodeUnreachableException;

    /**
     * Get the node information for the node with the given name.
     *
     * @param name The node name.
     *
     * @return The node information.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent NodeInfo getNodeInfo(string name)
      throws NodeNotExistException, NodeUnreachableException;

    /**
     * Get a proxy to the IceGrid node's admin object.
     *
     * @param name The IceGrid node name
     *
     * @return A proxy to the IceGrid node's admin object
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    [\\"cpp:const\\"]
    idempotent Object* getNodeAdmin(string name)
      throws NodeNotExistException, NodeUnreachableException;

    /**
     * Get the number of physical processor sockets for the machine running the
     * node with the given name.
     *
     * Note that this method will return 1 on operating systems where this can't
     * be automatically determined and where the
     * IceGrid.Node.ProcessorSocketCount property for the node is not set.
     *
     * @param name The node name.
     *
     * @return The number of processor sockets or 1 if the number of sockets
     * can't determined.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent int getNodeProcessorSocketCount(string name)
      throws NodeNotExistException, NodeUnreachableException;

    /**
     * Shutdown an IceGrid node.
     *
     * @param name The node name.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    void shutdownNode(string name)
      throws NodeNotExistException, NodeUnreachableException;

    /**
     * Get the hostname of this node.
     *
     * @param name The node name.
     *
     * @return The node hostname.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent string getNodeHostname(string name)
      throws NodeNotExistException, NodeUnreachableException;

    /**
     * Get all the IceGrid nodes currently registered.
     *
     * @return The node names.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent Ice::StringSeq getAllNodeNames();

    /**
     * Ping an IceGrid registry to see if it is active.
     *
     * @param name The registry name.
     *
     * @return true if the registry ping succeeded, false otherwise.
     *
     * @throws RegistryNotExistException Raised if the registry doesn't exist.
     **/
    [\\"cpp:const\\"]
    idempotent bool pingRegistry(string name) throws RegistryNotExistException;

    /**
     * Get the registry information for the registry with the given name.
     *
     * @param name The registry name.
     *
     * @return The registry information.
     *
     * @throws RegistryNotExistException Raised if the registry doesn't exist.
     *
     * @throws RegistryUnreachableException Raised if the registry could not be
     * reached.
     **/
    [\\"cpp:const\\"]
    idempotent RegistryInfo getRegistryInfo(string name)
      throws RegistryNotExistException, RegistryUnreachableException;

    /**
     * Get a proxy to the IceGrid registry's admin object.
     *
     * @param name The registry name
     *
     * @return A proxy to the IceGrid registry's admin object
     *
     * @throws RegistryNotExistException Raised if the registry doesn't exist.
     **/
    [\\"cpp:const\\"]
    idempotent Object* getRegistryAdmin(string name)
      throws RegistryNotExistException;

    /**
     * Shutdown an IceGrid registry.
     *
     * @param name The registry name.
     *
     * @throws RegistryNotExistException Raised if the registry doesn't exist.
     *
     * @throws RegistryUnreachableException Raised if the registry could not be
     * reached.
     **/
    idempotent void shutdownRegistry(string name)
      throws RegistryNotExistException, RegistryUnreachableException;

    /**
     * Get all the IceGrid registries currently registered.
     *
     * @return The registry names.
     **/
    [\\"cpp:const\\"] idempotent Ice::StringSeq getAllRegistryNames();

    /**
     * Shut down the IceGrid registry.
     **/
    void shutdown();

    /**
     * Returns the checksums for the IceGrid Slice definitions.
     *
     * @return A dictionary mapping Slice type ids to their checksums.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Ice::SliceChecksumDict getSliceChecksums();
  };

  /**
   * This interface provides access to IceGrid log file contents.
   **/
  interface FileIterator {
    /**
     * Read lines from the log file.
     *
     * @param size Specifies the maximum number of bytes to be received. The
     * server will ensure that the returned message doesn't exceed the given
     * size.
     *
     * @param lines The lines read from the file. If there was nothing to read
     * from the file since the last call to read, an empty sequence is returned.
     * The last line of the sequence is always incomplete (and therefore no '\\\\n'
     * should be added when writing the last line to the to the output device).
     *
     * @return True if EOF is encountered.
     *
     * @throws FileNotAvailableException Raised if there was a problem to read
     * lines from the file.
     **/
    bool read(int size, out Ice::StringSeq lines)
      throws FileNotAvailableException;

    /**
     * Destroy the iterator.
     **/
    void destroy();
  };

  /**
   * Dynamic information about the state of a server.
   **/
  struct ServerDynamicInfo {
    /**
     * The id of the server.
     **/
    string id;

    /**
     * The state of the server.
     **/
    ServerState state;

    /**
     * The process id of the server.
     **/
    int pid;

    /**
     * Indicates whether the server is enabled.
     **/
    bool enabled;
  };

  /**
   * A sequence of server dynamic information structures.
   **/
  [\\"java:type:java.util.LinkedList<ServerDynamicInfo>\\"]
  sequence<ServerDynamicInfo> ServerDynamicInfoSeq;

  /**
   * Dynamic information about the state of an adapter.
   **/
  struct AdapterDynamicInfo {
    /**
     * The id of the adapter.
     **/
    string id;

    /**
     * The direct proxy containing the adapter endpoints.
     **/
    Object* proxy;
  };

  /**
   * A sequence of adapter dynamic information structures.
   **/
  [\\"java:type:java.util.LinkedList<AdapterDynamicInfo>\\"]
  sequence<AdapterDynamicInfo> AdapterDynamicInfoSeq;

  /**
   * Dynamic information about the state of a node.
   **/
  struct NodeDynamicInfo {
    /**
     * Some static information about the node.
     **/
    NodeInfo info;

    /**
     * The dynamic information of the servers deployed on this node.
     **/
    ServerDynamicInfoSeq servers;

    /**
     * The dynamic information of the adapters deployed on this node.
     **/
    AdapterDynamicInfoSeq adapters;
  };

  /**
   * This interface allows applications to monitor changes the state of the
   * registry.
   **/
  interface RegistryObserver {
    /**
     * The <code>registryInit</code> operation is called after registration of
     * an observer to indicate the state of the registries.
     *
     * @param registries The current state of the registries.
     **/
    void registryInit(RegistryInfoSeq registries);

    /**
     * The <code>nodeUp</code> operation is called to notify an observer that a
     * node came up.
     *
     * @param node The node state.
     **/
    void registryUp(RegistryInfo node);

    /**
     * The <code>nodeDown</code> operation is called to notify an observer that
     * a node went down.
     *
     * @param name The node name.
     **/
    void registryDown(string name);
  };

  /**
   * A sequence of node dynamic information structures.
   **/
  sequence<NodeDynamicInfo> NodeDynamicInfoSeq;

  /**
   * The node observer interface. Observers should implement this interface to
   * receive information about the state of the IceGrid nodes.
   **/
  interface NodeObserver {
    /**
     * The <code>nodeInit</code> operation indicates the current state of nodes.
     * It is called after the registration of an observer.
     *
     * @param nodes The current state of the nodes.
     **/
    void nodeInit(NodeDynamicInfoSeq nodes);

    /**
     * The <code>nodeUp</code> operation is called to notify an observer that a
     * node came up.
     *
     * @param node The node state.
     **/
    void nodeUp(NodeDynamicInfo node);

    /**
     * The <code>nodeDown</code> operation is called to notify an observer that
     * a node went down.
     *
     * @param name The node name.
     **/
    void nodeDown(string name);

    /**
     * The <code>updateServer</code> operation is called to notify an observer
     * that the state of a server changed.
     *
     * @param node The node hosting the server.
     *
     * @param updatedInfo The new server state.
     **/
    void updateServer(string node, ServerDynamicInfo updatedInfo);

    /**
     * The <code>updateAdapter</code> operation is called to notify an observer
     * that the state of an adapter changed.
     *
     * @param node The node hosting the adapter.
     *
     * @param updatedInfo The new adapter state.
     **/
    void updateAdapter(string node, AdapterDynamicInfo updatedInfo);
  };

  /**
   * The database observer interface. Observers should implement this interface
   * to receive information about the state of the IceGrid registry database.
   **/
  interface ApplicationObserver {
    /**
     * <code>applicationInit</code> is called after the registration of an
     * observer to indicate the state of the registry.
     *
     * @param serial The current serial number of the registry database. This
     * serial number allows observers to make sure that their internal state is
     * synchronized with the registry.
     *
     * @param applications The applications currently registered with the
     * registry.
     **/
    void applicationInit(int serial, ApplicationInfoSeq applications);

    /**
     * The <code>applicationAdded</code> operation is called to notify an
     * observer that an application was added.
     *
     * @param serial The new serial number of the registry database.
     *
     * @param desc The descriptor of the new application.
     **/
    void applicationAdded(int serial, ApplicationInfo desc);

    /**
     * The <code>applicationRemoved</code> operation is called to notify an
     * observer that an application was removed.
     *
     * @param serial The new serial number of the registry database.
     *
     * @param name The name of the application that was removed.
     **/
    void applicationRemoved(int serial, string name);

    /**
     * The <code>applicationUpdated</code> operation is called to notify an
     * observer that an application was updated.
     *
     * @param serial The new serial number of the registry database.
     *
     * @param desc The descriptor of the update.
     **/
    void applicationUpdated(int serial, ApplicationUpdateInfo desc);
  };

  /**
   * This interface allows applications to monitor the state of object adapters
   * that are registered with IceGrid.
   **/
  interface AdapterObserver {
    /**
     * <code>adapterInit</code> is called after registration of an observer to
     * indicate the state of the registry.
     *
     * @param adpts The adapters that were dynamically registered with the
     * registry (not through the deployment mechanism).
     **/
    void adapterInit(AdapterInfoSeq adpts);

    /**
     * The <code>adapterAdded</code> operation is called to notify an observer
     * when a dynamically-registered adapter was added.
     *
     * @param info The details of the new adapter.
     **/
    void adapterAdded(AdapterInfo info);

    /**
     * The adapterUpdated operation is called to notify an observer when a
     * dynamically-registered adapter was updated.
     *
     * @param info The details of the updated adapter.
     **/
    void adapterUpdated(AdapterInfo info);

    /**
     * The adapterRemoved operation is called to notify an observer when a
     * dynamically-registered adapter was removed.
     *
     * @param id The ID of the removed adapter.
     **/
    void adapterRemoved(string id);
  };

  /**
   * This interface allows applications to monitor IceGrid well-known objects.
   **/
  interface ObjectObserver {
    /**
     * <code>objectInit</code> is called after the registration of an observer
     * to indicate the state of the registry.
     *
     * @param objects The objects registered with the {@link Admin} interface
     * (not through the deployment mechanism).
     **/
    void objectInit(ObjectInfoSeq objects);

    /**
     * The <code>objectAdded</code> operation is called to notify an observer
     * when an object was added to the {@link Admin} interface.
     *
     * @param info The details of the added object.
     **/
    void objectAdded(ObjectInfo info);

    /**
     * <code>objectUpdated</code> is called to notify an observer when an object
     * registered with the {@link Admin} interface was updated.
     *
     * @param info The details of the updated object.
     **/
    void objectUpdated(ObjectInfo info);

    /**
     * <code>objectRemoved</code> is called to notify an observer when an object
     * registered with the {@link Admin} interface was removed.
     *
     * @param id The identity of the removed object.
     **/
    void objectRemoved(Ice::Identity id);
  };

  /**
   * Used by administrative clients to view, update, and receive observer
   * updates from the IceGrid registry. Admin sessions are created either via
   * the {@link Registry} object or via the registry admin
   * <code>SessionManager</code> object.
   *
   * @see Registry
   **/
  interface AdminSession extends Glacier2::Session {
    /**
     * Keep the session alive. Clients should call this operation regularly to
     * prevent the server from reaping the session.
     *
     * @see Registry#getSessionTimeout
     **/
    idempotent void keepAlive();

    /**
     * Get the admin interface. The admin object returned by this operation can
     * only be accessed by the session.
     *
     * @return The admin interface proxy.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent Admin* getAdmin();

    /**
     * Get a \\"template\\" proxy for admin callback objects. An Admin client uses
     * this proxy to set the category of its callback objects, and the published
     * endpoints of the object adapter hosting the admin callback objects.
     *
     * @return A template proxy. The returned proxy is null when the Admin
     * session was established using Glacier2.
     **/
    [\\"cpp:const\\"] idempotent Object* getAdminCallbackTemplate();

    /**
     * Set the observer proxies that receive notifications when the state of the
     * registry or nodes changes.
     *
     * @param registryObs The registry observer.
     *
     * @param nodeObs The node observer.
     *
     * @param appObs The application observer.
     *
     * @param adptObs The adapter observer.
     *
     * @param objObs The object observer.
     *
     * @throws ObserverAlreadyRegisteredException Raised if an observer is
     * already registered with this registry.
     **/
    idempotent void setObservers(
      RegistryObserver* registryObs,
      NodeObserver* nodeObs,
      ApplicationObserver* appObs,
      AdapterObserver* adptObs,
      ObjectObserver* objObs
    )
      throws ObserverAlreadyRegisteredException;

    /**
     * Set the observer identities that receive notifications the state of the
     * registry or nodes changes. This operation should be used by clients that
     * are using a bidirectional connection to communicate with the session.
     *
     * @param registryObs The registry observer identity.
     *
     * @param nodeObs The node observer identity.
     *
     * @param appObs The application observer.
     *
     * @param adptObs The adapter observer.
     *
     * @param objObs The object observer.
     *
     * @throws ObserverAlreadyRegisteredException Raised if an observer is
     * already registered with this registry.
     **/
    idempotent void setObserversByIdentity(
      Ice::Identity registryObs,
      Ice::Identity nodeObs,
      Ice::Identity appObs,
      Ice::Identity adptObs,
      Ice::Identity objObs
    )
      throws ObserverAlreadyRegisteredException;

    /**
     * Acquires an exclusive lock to start updating the registry applications.
     *
     * @return The current serial.
     *
     * @throws AccessDeniedException Raised if the exclusive lock can't be
     * acquired. This might happen if the lock is currently acquired by another
     * session.
     **/
    int startUpdate() throws AccessDeniedException;

    /**
     * Finish updating the registry and release the exclusive lock.
     *
     * @throws AccessDeniedException Raised if the session doesn't hold the
     * exclusive lock.
     **/
    void finishUpdate() throws AccessDeniedException;

    /**
     * Get the name of the registry replica hosting this session.
     *
     * @return The replica name of the registry.
     **/
    [\\"cpp:const\\"] idempotent string getReplicaName();

    /**
     * Open the given server log file for reading. The file can be read with the
     * returned file iterator.
     *
     * @param id The server id.
     *
     * @param path The path of the log file. A log file can be opened only if
     * it's declared in the server or service deployment descriptor.
     *
     * @param count Specifies where to start reading the file. If negative, the
     * file is read from the begining. If 0 or positive, the file is read from
     * the last <code>count</code> lines.
     *
     * @return An iterator to read the file.
     *
     * @throws FileNotAvailableException Raised if the file can't be read.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    FileIterator* openServerLog(string id, string path, int count)
      throws
        FileNotAvailableException,
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Open the given server stderr file for reading. The file can be read with
     * the returned file iterator.
     *
     * @param id The server id.
     *
     * @param count Specifies where to start reading the file. If negative, the
     * file is read from the begining. If 0 or positive, the file is read from
     * the last <code>count</code> lines.
     *
     * @return An iterator to read the file.
     *
     * @throws FileNotAvailableException Raised if the file can't be read.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    FileIterator* openServerStdErr(string id, int count)
      throws
        FileNotAvailableException,
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Open the given server stdout file for reading. The file can be read with
     * the returned file iterator.
     *
     * @param id The server id.
     *
     * @param count Specifies where to start reading the file. If negative, the
     * file is read from the begining. If 0 or positive, the file is read from
     * the last <code>count</code> lines.
     *
     * @return An iterator to read the file.
     *
     * @throws FileNotAvailableException Raised if the file can't be read.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     *
     * @throws DeploymentException Raised if the server couldn't be deployed on
     * the node.
     **/
    FileIterator* openServerStdOut(string id, int count)
      throws
        FileNotAvailableException,
        ServerNotExistException,
        NodeUnreachableException,
        DeploymentException;

    /**
     * Open the given node stderr file for reading. The file can be read with
     * the returned file iterator.
     *
     * @param name The node name.
     *
     * @param count Specifies where to start reading the file. If negative, the
     * file is read from the begining. If 0 or positive, the file is read from
     * the last <code>count</code> lines.
     *
     * @return An iterator to read the file.
     *
     * @throws FileNotAvailableException Raised if the file can't be read.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    FileIterator* openNodeStdErr(string name, int count)
      throws
        FileNotAvailableException,
        NodeNotExistException,
        NodeUnreachableException;

    /**
     * Open the given node stdout file for reading. The file can be read with
     * the returned file iterator.
     *
     * @param name The node name.
     *
     * @param count Specifies where to start reading the file. If negative, the
     * file is read from the begining. If 0 or positive, the file is read from
     * the last <code>count</code> lines.
     *
     * @return An iterator to read the file.
     *
     * @throws FileNotAvailableException Raised if the file can't be read.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    FileIterator* openNodeStdOut(string name, int count)
      throws
        FileNotAvailableException,
        NodeNotExistException,
        NodeUnreachableException;

    /**
     * Open the given registry stderr file for reading. The file can be read
     * with the returned file iterator.
     *
     * @param name The registry name.
     *
     * @param count Specifies where to start reading the file. If negative, the
     * file is read from the begining. If 0 or positive, the file is read from
     * the last <code>count</code> lines.
     *
     * @return An iterator to read the file.
     *
     * @throws FileNotAvailableException Raised if the file can't be read.
     *
     * @throws RegistryNotExistException Raised if the registry doesn't exist.
     *
     * @throws RegistryUnreachableException Raised if the registry could not be
     * reached.
     **/
    FileIterator* openRegistryStdErr(string name, int count)
      throws
        FileNotAvailableException,
        RegistryNotExistException,
        RegistryUnreachableException;

    /**
     * Open the given registry stdout file for reading. The file can be read
     * with the returned file iterator.
     *
     * @param name The registry name.
     *
     * @param count Specifies where to start reading the file. If negative, the
     * file is read from the begining. If 0 or positive, the file is read from
     * the last <code>count</code> lines.
     *
     * @return An iterator to read the file.
     *
     * @throws FileNotAvailableException Raised if the file can't be read.
     *
     * @throws RegistryNotExistException Raised if the registry doesn't exist.
     *
     * @throws RegistryUnreachableException Raised if the registry could not be
     * reached.
     **/
    FileIterator * openRegistryStdOut(string name, int count)
      throws
        FileNotAvailableException,
        RegistryNotExistException,
        RegistryUnreachableException;

  };

};
"
`;

exports[`Built-in slices IceGrid/Descriptor.ice 1`] = `
"#pragma once

[[\\"cpp:doxygen:include:IceGrid/IceGrid.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceGrid/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceGrid\\"]]
[[\\"cpp:dll-export:ICEGRID_API\\"]]
[[\\"objc:dll-export:ICEGRID_API\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Identity.ice>
#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICEGRID\\"]
module IceGrid {
  /**
   * A mapping of string to string.
   **/
  dictionary<string, string> StringStringDict;

  /**
   * Property descriptor.
   **/
  struct PropertyDescriptor {
    /**
     * The name of the property.
     **/
    string name;

    /**
     * The value of the property.
     **/
    string value;
  };

  /**
   * A sequence of property descriptors.
   **/
  [\\"java:type:java.util.LinkedList<PropertyDescriptor>\\"]
  sequence<PropertyDescriptor> PropertyDescriptorSeq;

  /**
   * A property set descriptor.
   **/
  [\\"cpp:comparable\\"]
  struct PropertySetDescriptor {
    /**
     * References to named property sets.
     **/
    Ice::StringSeq references;

    /**
     * The property set properties.
     **/
    PropertyDescriptorSeq properties;
  };

  /**
   * A mapping of property set name to property set descriptor.
   **/
  dictionary<string, PropertySetDescriptor> PropertySetDescriptorDict;

  /**
   * An Ice object descriptor.
   **/
  struct ObjectDescriptor {
    /**
     * The identity of the object.
     **/
    Ice::Identity id;

    /**
     * The object type.
     **/
    string type;

    /**
     * Proxy options to use with the proxy created for this Ice object. If
     * empty, the proxy will be created with the proxy options specified on the
     * object adapter or replica group.
     **/
    string proxyOptions;
  };

  /**
   * A sequence of object descriptors.
   **/
  [\\"java:type:java.util.LinkedList<ObjectDescriptor>\\"]
  sequence<ObjectDescriptor> ObjectDescriptorSeq;

  /**
   * An Ice object adapter descriptor.
   **/
  [\\"cpp:comparable\\"]
  struct AdapterDescriptor {
    /**
     * The object adapter name.
     **/
    string name;

    /**
     * The description of this object adapter.
     **/
    string description;

    /**
     * The object adapter id.
     **/
    string id;

    /**
     * The replica id of this adapter.
     **/
    string replicaGroupId;

    /**
     * The adapter priority. This is eventually used when the adapter is member
     * of a replica group to sort the adapter endpoints by priority.
     **/
    string priority;

    /**
     * Flag to specify if the object adapter will register a process object.
     **/
    bool registerProcess;

    /**
     * If true the lifetime of this object adapter is the same of the server
     * lifetime. This information is used by the IceGrid node to figure out the
     * server state: the server is active only if all its \\"server lifetime\\"
     * adapters are active.
     **/
    bool serverLifetime;

    /**
     * The well-known object descriptors associated with this object adapter.
     **/
    ObjectDescriptorSeq objects;

    /**
     * The allocatable object descriptors associated with this object adapter.
     **/
    ObjectDescriptorSeq allocatables;
  };

  /**
   * A sequence of adapter descriptors.
   **/
  [\\"java:type:java.util.LinkedList<AdapterDescriptor>\\"]
  sequence<AdapterDescriptor> AdapterDescriptorSeq;

  /**
   * A Freeze database environment descriptor.
   **/
  [\\"cpp:comparable\\"]
  struct DbEnvDescriptor {
    /**
     * The name of the database environment.
     **/
    string name;

    /**
     * The description of this database environment.
     **/
    string description;

    /**
     * The home of the database environment (i.e., the directory where the
     * database files will be stored). If empty, the node will provide a default
     * database directory, otherwise the directory must exist.
     **/
    string dbHome;

    /**
     * The configuration properties of the database environment.
     **/
    PropertyDescriptorSeq properties;
  };

  /**
   * A sequence of database environment descriptors.
   **/
  [\\"java:type:java.util.LinkedList<DbEnvDescriptor>\\"]
  sequence<DbEnvDescriptor> DbEnvDescriptorSeq;

  /**
   * A communicator descriptor.
   **/
  class CommunicatorDescriptor {
    /**
     * The object adapters.
     **/
    AdapterDescriptorSeq adapters;

    /**
     * The property set.
     **/
    PropertySetDescriptor propertySet;

    /**
     * The database environments.
     **/
    DbEnvDescriptorSeq dbEnvs;

    /**
     * The path of each log file.
     **/
    Ice::StringSeq logs;

    /**
     * A description of this descriptor.
     **/
    string description;
  };

  /**
   * A distribution descriptor defines an IcePatch2 server and the directories
   * to retrieve from the patch server.
   **/
  [\\"cpp:comparable\\"]
  struct DistributionDescriptor {
    string icepatch;

    [\\"java:type:java.util.LinkedList<String>\\"]
    Ice::StringSeq directories;
  };

  /**
   * An Ice server descriptor.
   **/
  class ServerDescriptor extends CommunicatorDescriptor {
    /**
     * The server id.
     **/
    string id;

    /**
     * The path of the server executable.
     **/
    string exe;

    /**
     * The Ice version used by this server. This is only required if backward
     * compatibility with servers using old Ice versions is needed (otherwise
     * the registry will assume the server is using the same Ice version). For
     * example \\"3.1.1\\", \\"3.2\\", \\"3.3.0\\".
     **/
    string iceVersion;

    /**
     * The path to the server working directory.
     **/
    string pwd;

    /**
     * The command line options to pass to the server executable.
     **/
    [\\"java:type:java.util.LinkedList<String>\\"]
    Ice::StringSeq options;

    /**
     * The server environment variables.
     **/
    [\\"java:type:java.util.LinkedList<String>\\"]
    Ice::StringSeq envs;

    /**
     * The server activation mode (possible values are \\"on-demand\\" or
     * \\"manual\\").
     **/
    string activation;

    /**
     * The activation timeout (an integer value representing the number of
     * seconds to wait for activation).
     **/
    string activationTimeout;

    /**
     * The deactivation timeout (an integer value representing the number of
     * seconds to wait for deactivation).
     **/
    string deactivationTimeout;

    /**
     * Specifies if the server depends on the application distribution.
     **/
    bool applicationDistrib;

    /**
     * The distribution descriptor.
     **/
    DistributionDescriptor distrib;

    /**
     * Specifies if the server is allocatable.
     **/
    bool allocatable;

    /**
     * The user account used to run the server.
     **/
    string user;
  };

  /**
   * A sequence of server descriptors.
   **/
  [\\"java:type:java.util.LinkedList<ServerDescriptor>\\"]
  sequence<ServerDescriptor> ServerDescriptorSeq;

  /**
   * An IceBox service descriptor.
   **/
  class ServiceDescriptor extends CommunicatorDescriptor {
    /**
     * The service name.
     **/
    string name;

    /**
     * The entry point of the IceBox service.
     **/
    string entry;
  };

  /**
   * A sequence of service descriptors.
   **/
  [\\"java:type:java.util.LinkedList<ServiceDescriptor>\\"]
  sequence<ServiceDescriptor> ServiceDescriptorSeq;

  /**
   * A server template instance descriptor.
   **/
  [\\"cpp:comparable\\"]
  struct ServerInstanceDescriptor {
    /**
     * The template used by this instance.
     **/
    string template;

    /**
     * The template parameter values.
     **/
    StringStringDict parameterValues;

    /**
     * The property set.
     **/
    PropertySetDescriptor propertySet;

    /**
     * The services property sets. It's only valid to set these property sets if
     * the template is an IceBox server template.
     **/
    PropertySetDescriptorDict servicePropertySets;
  };

  /**
   * A sequence of server instance descriptors.
   **/
  [\\"java:type:java.util.LinkedList<ServerInstanceDescriptor>\\"]
  sequence<ServerInstanceDescriptor> ServerInstanceDescriptorSeq;

  /**
   * A template descriptor for server or service templates.
   **/
  struct TemplateDescriptor {
    /**
     * The template.
     **/
    CommunicatorDescriptor descriptor;

    /**
     * The parameters required to instantiate the template.
     **/
    [\\"java:type:java.util.LinkedList<String>\\"]
    Ice::StringSeq parameters;

    /**
     * The parameters default values.
     **/
    StringStringDict parameterDefaults;
  };

  /**
   * A mapping of template identifier to template descriptor.
   **/
  dictionary<string, TemplateDescriptor> TemplateDescriptorDict;

  /**
   * A service template instance descriptor.
   **/
  struct ServiceInstanceDescriptor {
    /**
     * The template used by this instance.
     **/
    string template;

    /**
     * The template parameter values.
     **/
    StringStringDict parameterValues;

    /**
     * The service definition if the instance isn't a template instance (i.e.:
     * if the template attribute is empty).
     **/
    ServiceDescriptor descriptor;

    /**
     * The property set.
     **/
    PropertySetDescriptor propertySet;
  };

  /**
   * A sequence of service instance descriptors.
   **/
  [\\"java:type:java.util.LinkedList<ServiceInstanceDescriptor>\\"]
  sequence<ServiceInstanceDescriptor> ServiceInstanceDescriptorSeq;

  /**
   * An IceBox server descriptor.
   **/
  class IceBoxDescriptor extends ServerDescriptor {
    /**
     * The service instances.
     **/
    ServiceInstanceDescriptorSeq services;
  };

  /**
   * A node descriptor.
   **/
  struct NodeDescriptor {
    /**
     * The variables defined for the node.
     **/
    [\\"java:type:java.util.TreeMap<String, String>\\"]
    StringStringDict variables;

    /**
     * The server instances.
     **/
    ServerInstanceDescriptorSeq serverInstances;

    /**
     * Servers (which are not template instances).
     **/
    ServerDescriptorSeq servers;

    /**
     * Load factor of the node.
     **/
    string loadFactor;

    /**
     * The description of this node.
     **/
    string description;

    /**
     * Property set descriptors.
     **/
    PropertySetDescriptorDict propertySets;
  };

  /**
   * Mapping of node name to node descriptor.
   **/
  dictionary<string, NodeDescriptor> NodeDescriptorDict;

  /**
   * A base class for load balancing policies.
   **/
  class LoadBalancingPolicy {
    /**
     * The number of replicas that will be used to gather the endpoints of a
     * replica group.
     **/
    string nReplicas;
  };

  /**
   * Random load balancing policy.
   **/
  class RandomLoadBalancingPolicy extends LoadBalancingPolicy {};

  /**
   * Ordered load balancing policy.
   **/
  class OrderedLoadBalancingPolicy extends LoadBalancingPolicy {};

  /**
   * Round robin load balancing policy.
   **/
  class RoundRobinLoadBalancingPolicy extends LoadBalancingPolicy {};

  /**
   * Adaptive load balancing policy.
   **/
  class AdaptiveLoadBalancingPolicy extends LoadBalancingPolicy {
    /**
     * The load sample to use for the load balancing. The allowed values for
     * this attribute are \\"1\\", \\"5\\" and \\"15\\", representing respectively the load
     * average over the past minute, the past 5 minutes and the past 15 minutes.
     **/
    string loadSample;
  };

  /**
   * A replica group descriptor.
   **/
  struct ReplicaGroupDescriptor {
    /**
     * The id of the replica group.
     **/
    string id;

    /**
     * The load balancing policy.
     **/
    LoadBalancingPolicy loadBalancing;

    /**
     * Default options for proxies created for the replica group.
     **/
    string proxyOptions;

    /**
     * The object descriptors associated with this object adapter.
     **/
    ObjectDescriptorSeq objects;

    /**
     * The description of this replica group.
     **/
    string description;

    /**
     * The filter to use for this replica group.
     **/
    string filter;
  };

  /**
   * A sequence of replica groups.
   **/
  [\\"java:type:java.util.LinkedList<ReplicaGroupDescriptor>\\"]
  sequence<ReplicaGroupDescriptor> ReplicaGroupDescriptorSeq;

  /**
   * An application descriptor.
   **/
  struct ApplicationDescriptor {
    /**
     * The application name.
     **/
    string name;

    /**
     * The variables defined in the application descriptor.
     **/
    [\\"java:type:java.util.TreeMap<String, String>\\"]
    StringStringDict variables;

    /**
     * The replica groups.
     **/
    ReplicaGroupDescriptorSeq replicaGroups;

    /**
     * The server templates.
     **/
    TemplateDescriptorDict serverTemplates;

    /**
     * The service templates.
     **/
    TemplateDescriptorDict serviceTemplates;

    /**
     * The application nodes.
     **/
    NodeDescriptorDict nodes;

    /**
     * The application distribution.
     **/
    DistributionDescriptor distrib;

    /**
     * The description of this application.
     **/
    string description;

    /**
     * Property set descriptors.
     **/
    PropertySetDescriptorDict propertySets;
  };

  /**
   * A sequence of application descriptors.
   **/
  [\\"java:type:java.util.LinkedList<ApplicationDescriptor>\\"]
  sequence<ApplicationDescriptor> ApplicationDescriptorSeq;

  /**
   * A \\"boxed\\" string.
   **/
  class BoxedString {
    string value;
  };

  /**
   * A node update descriptor to describe the updates to apply to a node of a
   * deployed application.
   **/
  struct NodeUpdateDescriptor {
    /**
     * The name of the node to update.
     **/
    string name;

    /**
     * The updated description (or null if the description wasn't updated.)
     **/
    BoxedString description;

    /**
     * The variables to update.
     **/
    [\\"java:type:java.util.TreeMap<String, String>\\"]
    StringStringDict variables;

    /**
     * The variables to remove.
     **/
    Ice::StringSeq removeVariables;

    /**
     * The property sets to update.
     **/
    PropertySetDescriptorDict propertySets;

    /**
     * The property sets to remove.
     **/
    Ice::StringSeq removePropertySets;

    /**
     * The server instances to update.
     **/
    ServerInstanceDescriptorSeq serverInstances;

    /**
     * The servers which are not template instances to update.
     **/
    ServerDescriptorSeq servers;

    /**
     * The ids of the servers to remove.
     **/
    Ice::StringSeq removeServers;

    /**
     * The updated load factor of the node (or null if the load factor was not
     * updated).
     **/
    BoxedString loadFactor;
  };

  /**
   * A sequence of node update descriptors.
   **/
  [\\"java:type:java.util.LinkedList<NodeUpdateDescriptor>\\"]
  sequence<NodeUpdateDescriptor> NodeUpdateDescriptorSeq;

  /**
   * A \\"boxed\\" distribution descriptor.
   **/
  class BoxedDistributionDescriptor {
    DistributionDescriptor value;
  };

  /**
   * An application update descriptor to describe the updates to apply to a
   * deployed application.
   **/
  struct ApplicationUpdateDescriptor {
    /**
     * The name of the application to update.
     **/
    string name;

    /**
     * The updated description (or null if the description wasn't updated.)
     **/
    BoxedString description;

    /**
     * The updated distribution application descriptor.
     **/
    BoxedDistributionDescriptor distrib;

    /**
     * The variables to update.
     **/
    [\\"java:type:java.util.TreeMap<String, String>\\"]
    StringStringDict variables;

    /**
     * The variables to remove.
     **/
    Ice::StringSeq removeVariables;

    /**
     * The property sets to update.
     **/
    PropertySetDescriptorDict propertySets;

    /**
     * The property sets to remove.
     **/
    Ice::StringSeq removePropertySets;

    /**
     * The replica groups to update.
     **/
    ReplicaGroupDescriptorSeq replicaGroups;

    /**
     * The replica groups to remove.
     **/
    Ice::StringSeq removeReplicaGroups;

    /**
     * The server templates to update.
     **/
    TemplateDescriptorDict serverTemplates;

    /**
     * The ids of the server template to remove.
     **/
    Ice::StringSeq removeServerTemplates;

    /**
     * The service templates to update.
     **/
    TemplateDescriptorDict serviceTemplates;

    /**
     * The ids of the service template to remove.
     **/
    Ice::StringSeq removeServiceTemplates;

    /**
     * The application nodes to update.
     **/
    NodeUpdateDescriptorSeq nodes;

    /**
     * The nodes to remove.
     **/
    Ice::StringSeq removeNodes;
  };

};
"
`;

exports[`Built-in slices IceGrid/Exception.ice 1`] = `
"#pragma once

[[\\"cpp:doxygen:include:IceGrid/IceGrid.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceGrid/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceGrid\\"]]
[[\\"cpp:dll-export:ICEGRID_API\\"]]
[[\\"objc:dll-export:ICEGRID_API\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Identity.ice>
#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICEGRID\\"]
module IceGrid {
  /**
   * This exception is raised if an application does not exist.
   **/
  exception ApplicationNotExistException {
    /**
     * The name of the application.
     **/
    string name;
  };

  /**
   * This exception is raised if a server does not exist.
   **/
  exception ServerNotExistException {
    /**
     * The identifier of the server.
     **/
    string id;
  };

  /**
   * This exception is raised if a server failed to start.
   **/
  exception ServerStartException {
    /**
     * The identifier of the server.
     **/
    string id;

    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception is raised if a server failed to stop.
   **/
  exception ServerStopException {
    /**
     * The identifier of the server.
     **/
    string id;

    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception is raised if an adapter does not exist.
   **/
  exception AdapterNotExistException {
    /**
     * The id of the object adapter.
     **/
    string id;
  };

  /**
   * This exception is raised if an object already exists.
   **/
  exception ObjectExistsException {
    /**
     * The identity of the object.
     **/
    Ice::Identity id;
  };

  /**
   * This exception is raised if an object is not registered.
   **/
  exception ObjectNotRegisteredException {
    /**
     * The identity of the object.
     **/
    Ice::Identity id;
  };

  /**
   * This exception is raised if a node does not exist.
   **/
  exception NodeNotExistException {
    /**
     * The node name.
     **/
    string name;
  };

  /**
   * This exception is raised if a registry does not exist.
   **/
  exception RegistryNotExistException {
    /**
     * The registry name.
     **/
    string name;
  };

  /**
   * An exception for deployment errors.
   **/
  exception DeploymentException {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception is raised if a node could not be reached.
   **/
  exception NodeUnreachableException {
    /**
     * The name of the node that is not reachable.
     **/
    string name;

    /**
     * The reason why the node couldn't be reached.
     **/
    string reason;
  };

  /**
   * This exception is raised if a server could not be reached.
   **/
  exception ServerUnreachableException {
    /**
     * The id of the server that is not reachable.
     **/
    string name;

    /**
     * The reason why the server couldn't be reached.
     **/
    string reason;
  };

  /**
   * This exception is raised if a registry could not be reached.
   **/
  exception RegistryUnreachableException {
    /**
     * The name of the registry that is not reachable.
     **/
    string name;

    /**
     * The reason why the registry couldn't be reached.
     **/
    string reason;
  };

  /**
   * This exception is raised if an unknown signal was sent to to a server.
   **/
  exception BadSignalException {
    /**
     * The details of the unknown signal.
     **/
    string reason;
  };

  /**
   * This exception is raised if a patch failed.
   **/
  exception PatchException {
    /**
     * The reasons why the patch failed.
     **/
    Ice::StringSeq reasons;
  };

  /**
   * *
   * * This exception is raised if a registry lock wasn't
   *  * acquired or is already held by a session.
   * *
   **/
  exception AccessDeniedException {
    /**
     * The id of the user holding the lock (if any).
     **/
    string lockUserId;
  };

  /**
   * This exception is raised if the allocation of an object failed.
   **/
  exception AllocationException {
    /**
     * The reason why the object couldn't be allocated.
     **/
    string reason;
  };

  /**
   * This exception is raised if the request to allocate an object times out.
   **/
  exception AllocationTimeoutException extends AllocationException {};

  /**
   * This exception is raised if a client is denied the ability to create a
   * session with IceGrid.
   **/
  exception PermissionDeniedException {
    /**
     * The reason why permission was denied.
     **/
    string reason;
  };

  /**
   * This exception is raised if an observer is already registered with the
   * registry.
   *
   * @see AdminSession#setObservers
   * @see AdminSession#setObserversByIdentity
   **/
  exception ObserverAlreadyRegisteredException {
    /**
     * The identity of the observer.
     **/
    Ice::Identity id;
  };

  /**
   * This exception is raised if a file is not available.
   *
   * @see AdminSession#openServerStdOut
   * @see AdminSession#openServerStdErr
   * @see AdminSession#openNodeStdOut
   * @see AdminSession#openNodeStdErr
   * @see AdminSession#openRegistryStdOut
   * @see AdminSession#openRegistryStdErr
   **/
  exception FileNotAvailableException {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

};
"
`;

exports[`Built-in slices IceGrid/FileParser.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEGRID_API\\"]]
[[\\"cpp:doxygen:include:IceGrid/IceGrid.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceGrid/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICEGRID_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceGrid\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <IceGrid/Admin.ice>

[\\"objc:prefix:ICEGRID\\"]
module IceGrid {
  /**
   * This exception is raised if an error occurs during parsing.
   **/
  exception ParseException {
    string reason;
  };

  /**
   * <code>icegridadmin</code> provides a {@link FileParser} object to transform
   * XML files into {@link ApplicationDescriptor} objects.
   **/
  interface FileParser {
    /**
     * Parse a file.
     *
     * @param xmlFile Full pathname to the file.
     *
     * @param adminProxy An Admin proxy, used only to retrieve default templates
     * when needed. May be null.
     *
     * @return The application descriptor.
     *
     * @throws ParseException Raised if an error occurred during parsing.
     **/
    idempotent ApplicationDescriptor parse(string xmlFile, Admin* adminProxy)
      throws ParseException;
  };

};
"
`;

exports[`Built-in slices IceGrid/PluginFacade.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEGRID_API\\"]]
[[\\"cpp:doxygen:include:IceGrid/IceGrid.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceGrid/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICEGRID_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceGrid\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>
#include <Ice/Current.ice>
#include <IceGrid/Admin.ice>

[\\"objc:prefix:ICEGRID\\"]
module IceGrid {
  /**
   * The ReplicaGroupFilter is used by IceGrid to filter adapters returned to
   * the client when it resolves a filtered replica group.
   *
   * IceGrid provides the list of available adapters. The implementation of this
   * method can use the provided context and connection to filter and return the
   * filtered set of adapters.
   **/
  local interface ReplicaGroupFilter {
    /**
     * Filter the the given set of adapters.
     *
     * @param replicaGroupId The replica group ID.
     *
     * @param adapterIds The adpater IDs to filter.
     *
     * @param con The connection from the Ice client which is resolving the
     * replica group endpoints.
     *
     * @param ctx The context from the Ice client which is resolving the replica
     * group endpoints.
     *
     * @return The filtered adapter IDs.
     **/
    Ice::StringSeq filter(
      string replicaGroupId,
      Ice::StringSeq adapterIds,
      Ice::Connection con,
      Ice::Context ctx
    );
  };

  /**
   * The TypeFilter is used by IceGrid to filter well-known proxies returned to
   * the client when it searches a well-known object by type.
   *
   * IceGrid provides the list of available proxies. The implementation of this
   * method can use the provided context and connection to filter and return the
   * filtered set of proxies.
   **/
  local interface TypeFilter {
    /**
     * Filter the the given set of proxies.
     *
     * @param type The type.
     *
     * @param proxies The proxies to filter.
     *
     * @param con The connection from the Ice client which is looking up
     * well-known objects by type.
     *
     * @param ctx The context from the Ice client which is looking up well-known
     * objects by type.
     *
     * @return The filtered proxies.
     **/
    Ice::ObjectProxySeq filter(
      string type,
      Ice::ObjectProxySeq proxies,
      Ice::Connection con,
      Ice::Context ctx
    );
  };

  /**
   * The RegistryPluginFacade is implemented by IceGrid and can be used by
   * plugins and filter implementations to retrieve information from IceGrid
   * about the well-known objects or adapters. It's also used to
   * register/unregister replica group and type filters.
   **/
  local interface RegistryPluginFacade {
    /**
     * Get an application descriptor.
     *
     * @param name The application name.
     *
     * @return The application descriptor.
     *
     * @throws ApplicationNotExistException Raised if the application doesn't
     * exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ApplicationInfo getApplicationInfo(string name)
      throws ApplicationNotExistException;

    /**
     * Get the server information for the server with the given id.
     *
     * @param id The server id.
     *
     * @throws ServerNotExistException Raised if the server doesn't exist.
     *
     * @return The server information.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ServerInfo getServerInfo(string id)
      throws ServerNotExistException;

    /**
     * Get the ID of the server to which the given adapter belongs.
     *
     * @param adapterId The adapter ID.
     *
     * @return The server ID or the empty string if the given identifier is not
     * associated to an object adapter defined with an application descriptor.
     *
     * @throws AdapterNotExistException Raised if the adapter doesn't exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent string getAdapterServer(string adapterId)
      throws AdapterNotExistException;

    /**
     * Get the name of the application to which the given adapter belongs.
     *
     * @param adapterId The adapter ID.
     *
     * @return The application name or the empty string if the given identifier
     * is not associated to a replica group or object adapter defined with an
     * application descriptor.
     *
     * @throws AdapterNotExistException Raised if the adapter doesn't exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent string getAdapterApplication(string adapterId)
      throws AdapterNotExistException;

    /**
     * Get the name of the node to which the given adapter belongs.
     *
     * @param adapterId The adapter ID.
     *
     * @return The node name or the empty string if the given identifier is not
     * associated to an object adapter defined with an application descriptor.
     *
     * @throws AdapterNotExistException Raised if the adapter doesn't exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent string getAdapterNode(string adapterId)
      throws AdapterNotExistException;

    /**
     * Get the adapter information for the replica group or adapter with the
     * given id.
     *
     * @param id The adapter id.
     *
     * @return A sequence of adapter information structures. If the given id
     * refers to an adapter, this sequence will contain only one element. If the
     * given id refers to a replica group, the sequence will contain the adapter
     * information of each member of the replica group.
     *
     * @throws AdapterNotExistException Raised if the adapter or replica group
     * doesn't exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent AdapterInfoSeq getAdapterInfo(string id)
      throws AdapterNotExistException;

    /**
     * Get the object info for the object with the given identity.
     *
     * @param id The identity of the object.
     *
     * @return The object info.
     *
     * @throws ObjectNotRegisteredException Raised if the object isn't
     * registered with the registry.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent ObjectInfo getObjectInfo(Ice::Identity id)
      throws ObjectNotRegisteredException;

    /**
     * Get the node information for the node with the given name.
     *
     * @param name The node name.
     *
     * @return The node information.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent NodeInfo getNodeInfo(string name)
      throws NodeNotExistException, NodeUnreachableException;

    /**
     * Get the load averages of the node.
     *
     * @param name The node name.
     *
     * @return The node load information.
     *
     * @throws NodeNotExistException Raised if the node doesn't exist.
     *
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent LoadInfo getNodeLoad(string name)
      throws NodeNotExistException, NodeUnreachableException;

    /**
     * Get the property value for the given property and adapter. The property
     * is looked up in the server or service descriptor where the adapter is
     * defined.
     *
     * @param adapterId The adapter ID
     *
     * @param name The name of the property.
     *
     * @return The property value.
     *
     * @throws AdapterNotExistException Raised if the adapter doesn't exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent string getPropertyForAdapter(string adapterId, string name)
      throws AdapterNotExistException;

    /**
     * Add a replica group filter.
     *
     * @param id The identifier of the filter. This identifier must match the
     * value of the \\"filter\\" attribute specified in the replica group
     * descriptor. To filter dynamically registered replica groups, you should
     * use the empty filter id.
     *
     * @param filter The filter implementation.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"]
    void addReplicaGroupFilter(string id, ReplicaGroupFilter filter);

    /**
     * Remove a replica group filter.
     *
     * @param id The identifier of the filter.
     *
     * @param filter The filter implementation.
     *
     * @return True of the filter was removed, false otherwise.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"]
    bool removeReplicaGroupFilter(string id, ReplicaGroupFilter filter);

    /**
     * Add a type filter.
     *
     * @param type The type to register this filter with.
     *
     * @param filter The filter implementation.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"]
    void addTypeFilter(string type, TypeFilter filter);

    /**
     * Remove a type filter.
     *
     * @param type The type to register this filter with.
     *
     * @param filter The filter implementation.
     *
     * @return True of the filter was removed, false otherwise.
     **/
    [\\"cpp:noexcept\\", \\"swift:noexcept\\"]
    bool removeTypeFilter(string type, TypeFilter filter);
  };

};
"
`;

exports[`Built-in slices IceGrid/Registry.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEGRID_API\\"]]
[[\\"cpp:doxygen:include:IceGrid/IceGrid.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceGrid/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICEGRID_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceGrid\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <IceGrid/Exception.ice>
#include <IceGrid/Session.ice>
#include <IceGrid/Admin.ice>
#include <Ice/Locator.ice>

[\\"objc:prefix:ICEGRID\\"]
module IceGrid {
  /**
   * Determines which load sampling interval to use.
   **/
  enum LoadSample {
    /**
     * Sample every minute.
     **/
    LoadSample1,

    /**
     * Sample every five minutes.
     **/
    LoadSample5,

    /**
     * Sample every fifteen minutes.
     **/
    LoadSample15,
  };

  /**
   * The IceGrid query interface. This interface is accessible to Ice clients
   * who wish to look up well-known objects.
   **/
  interface Query {
    /**
     * Find a well-known object by identity.
     *
     * @param id The identity.
     *
     * @return The proxy or null if no such object has been found.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Object* findObjectById(Ice::Identity id);

    /**
     * Find a well-known object by type. If there are several objects registered
     * for the given type, the object is randomly selected.
     *
     * @param type The object type.
     *
     * @return The proxy or null, if no such object has been found.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Object* findObjectByType(string type);

    /**
     * Find a well-known object by type on the least-loaded node. If the
     * registry does not know which node hosts the object
     * (for example, because the object was registered with a direct proxy), the
     * registry assumes the object is hosted on a node that has a load average of
     * 1.0.
     *
     * @param type The object type.
     *
     * @param sample The sampling interval.
     *
     * @return The proxy or null, if no such object has been found.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Object* findObjectByTypeOnLeastLoadedNode(
      string type,
      LoadSample sample
    );

    /**
     * Find all the well-known objects with the given type.
     *
     * @param type The object type.
     *
     * @return The proxies or an empty sequence, if no such objects have been
     * found.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Ice::ObjectProxySeq findAllObjectsByType(string type);

    /**
     * Find all the object replicas associated with the given proxy. If the
     * given proxy is not an indirect proxy from a replica group, an empty
     * sequence is returned.
     *
     * @param proxy The object proxy.
     *
     * @return The proxies of each object replica or an empty sequence, if the
     * given proxy is not from a replica group.
     **/
    [\\"cpp:const\\"] idempotent Ice::ObjectProxySeq findAllReplicas(Object* proxy);
  };

  /**
   * The IceGrid registry allows clients create sessions directly with the
   * registry.
   *
   * @see Session
   * @see AdminSession
   **/
  interface Registry {
    /**
     * Create a client session.
     *
     * @return A proxy for the newly created session.
     *
     * @param userId The user id.
     *
     * @param password The password for the given user id.
     *
     * @throws PermissionDeniedException Raised if the password for the given
     * user id is not correct, or if the user is not allowed access.
     **/
    Session* createSession(string userId, string password)
      throws PermissionDeniedException;

    /**
     * Create an administrative session.
     *
     * @return A proxy for the newly created session.
     *
     * @param userId The user id.
     *
     * @param password The password for the given user id.
     *
     * @throws PermissionDeniedException Raised if the password for the given
     * user id is not correct, or if the user is not allowed access.
     **/
    AdminSession* createAdminSession(string userId, string password)
      throws PermissionDeniedException;

    /**
     * Create a client session from a secure connection.
     *
     * @return A proxy for the newly created session.
     *
     * @throws PermissionDeniedException Raised if the password for the given
     * user id is not correct, or if the user is not allowed access.
     **/
    Session* createSessionFromSecureConnection()
      throws PermissionDeniedException;

    /**
     * Create an administrative session from a secure connection.
     *
     * @return A proxy for the newly created session.
     *
     * @throws PermissionDeniedException Raised if the password for the given
     * user id is not correct, or if the user is not allowed access.
     **/
    AdminSession* createAdminSessionFromSecureConnection()
      throws PermissionDeniedException;

    /**
     * Get the session timeout. If a client or administrative client doesn't
     * call the session keepAlive method in the time interval defined by this
     * timeout, IceGrid might reap the session.
     *
     * @see Session#keepAlive
     * @see AdminSession#keepAlive
     *
     * @return The timeout (in seconds).
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent int getSessionTimeout();

    /**
     * Get the value of the ACM timeout. Clients supporting ACM connection
     * heartbeats can enable them instead of explicitly sending keep alives
     * requests.
     *
     * NOTE: This method is only available since Ice 3.6.
     *
     * @return The timeout (in seconds).
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent int getACMTimeout();
  };

  /**
   * The IceGrid locator interface provides access to the {@link Query} and
   * {@link Registry} object of the IceGrid registry.
   *
   * @see Query
   * @see Registry
   **/
  interface Locator extends Ice::Locator {
    /**
     * Get the proxy of the registry object hosted by this IceGrid registry.
     *
     * @return The proxy of the registry object.
     **/
    [\\"cpp:const\\"] idempotent Registry* getLocalRegistry();

    /**
     * Get the proxy of the query object hosted by this IceGrid registry.
     *
     * @return The proxy of the query object.
     **/
    [\\"cpp:const\\"] idempotent Query* getLocalQuery();
  };

};
"
`;

exports[`Built-in slices IceGrid/Session.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEGRID_API\\"]]
[[\\"cpp:doxygen:include:IceGrid/IceGrid.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceGrid/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICEGRID_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceGrid\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Glacier2/Session.ice>
#include <IceGrid/Exception.ice>

[\\"objc:prefix:ICEGRID\\"]
module IceGrid {
  /**
   * A session object is used by IceGrid clients to allocate and release
   * objects. Client sessions are created either via the
   * {@link Registry} object or via the registry client <code>SessionManager</code>
   * object.
   *
   * @see Registry
   **/
  interface Session extends Glacier2::Session {
    /**
     * Keep the session alive. Clients should call this operation regularly to
     * prevent the server from reaping the session.
     *
     * @see Registry#getSessionTimeout
     **/
    idempotent void keepAlive();

    /**
     * Allocate an object. Depending on the allocation timeout, this operation
     * might hang until the object is available or until the timeout is reached.
     *
     * @param id The identity of the object to allocate.
     *
     * @return The proxy of the allocated object.
     *
     * @throws ObjectNotRegisteredException Raised if the object with the given
     * identity is not registered with the registry.
     *
     * @throws AllocationException Raised if the object can't be allocated.
     *
     * @see #setAllocationTimeout
     * @see #releaseObject
     **/
    [\\"amd\\"]
    Object* allocateObjectById(Ice::Identity id)
      throws ObjectNotRegisteredException, AllocationException;

    /**
     * Allocate an object with the given type. Depending on the allocation
     * timeout, this operation can block until an object becomes available or
     * until the timeout is reached.
     *
     * @param type The type of the object.
     *
     * @return The proxy of the allocated object.
     *
     * @throws AllocationException Raised if the object could not be allocated.
     *
     * @see #setAllocationTimeout
     * @see #releaseObject
     **/
    [\\"amd\\"]
    Object* allocateObjectByType(string type) throws AllocationException;

    /**
     * Release an object that was allocated using
     * <code>allocateObjectById</code> or
     * <code>allocateObjectByType</code>.
     *
     * @param id The identity of the object to release.
     *
     * @throws ObjectNotRegisteredException Raised if the object with the given
     * identity is not registered with the registry.
     *
     * @throws AllocationException Raised if the given object can't be released.
     * This might happen if the object isn't allocatable or isn't allocated by
     * the session.
     **/
    void releaseObject(Ice::Identity id)
      throws ObjectNotRegisteredException, AllocationException;

    /**
     * Set the allocation timeout. If no objects are available for an allocation
     * request, a call to <code>allocateObjectById</code> or
     * <code>allocateObjectByType</code> will block for the duration of this timeout.
     *
     * @param timeout The timeout in milliseconds.
     **/
    idempotent void setAllocationTimeout(int timeout);
  };

};
"
`;

exports[`Built-in slices IceGrid/UserAccountMapper.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEGRID_API\\"]]
[[\\"cpp:doxygen:include:IceGrid/IceGrid.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceGrid/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICEGRID_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceGrid\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICEGRID\\"]
module IceGrid {
  /**
   * This exception is raised if a user account for a given session identifier
   * can't be found.
   **/
  exception UserAccountNotFoundException {};

  /**
   * A user account mapper object is used by IceGrid nodes to map session
   * identifiers to user accounts.
   **/
  interface UserAccountMapper {
    /**
     * Get the name of the user account for the given user. This is used by
     * IceGrid nodes to figure out the user account to use to run servers.
     *
     * @param user The value of the server descriptor's <code>user</code>
     * attribute. If this attribute is not defined, and the server's activation
     * mode is <code>session</code>, the default value of
     * <code>user</code> is the session identifier.
     *
     * @return The user account name.
     *
     * @throws UserAccountNotFoundException Raised if no user account is found
     * for the given user.
     **/
    string getUserAccount(string user) throws UserAccountNotFoundException;
  };

};
"
`;

exports[`Built-in slices IceIAP/ConnectionInfo.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEIAP_API\\"]]
[[\\"cpp:doxygen:include:IceIAP/IceIAP.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]

#include <Ice/Connection.ice>

[\\"objc:prefix:ICEIAP\\", \\"swift:module:Ice:IAP\\"]
module IceIAP {
  /**
   * Provides access to the connection details of an IAP connection
   **/
  local class ConnectionInfo extends Ice::ConnectionInfo {
    /**
     * The accessory name.
     **/
    string name;

    /**
     * The accessory manufacturer.
     **/
    string manufacturer;

    /**
     * The accessory model number.
     **/
    string modelNumber;

    /**
     * The accessory firmare revision.
     **/
    string firmwareRevision;

    /**
     * The accessory hardware revision.
     **/
    string hardwareRevision;

    /**
     * The protocol used by the accessory.
     **/
    string protocol;
  };

};
"
`;

exports[`Built-in slices IceIAP/EndpointInfo.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEIAP_API\\"]]
[[\\"cpp:doxygen:include:IceIAP/IceIAP.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]

#include <Ice/Endpoint.ice>

/**
 * IceIAP provides a secure transport for Ice.
 **/
[\\"objc:prefix:ICEIAP\\", \\"swift:module:Ice:IAP\\"]
module IceIAP {
  /**
   * Provides access to an IAP endpoint information.
   **/
  local class EndpointInfo extends Ice::EndpointInfo {
    /**
     * The accessory manufacturer or empty to not match against a manufacturer.
     **/
    string manufacturer;

    /**
     * The accessory model number or empty to not match against a model number.
     **/
    string modelNumber;

    /**
     * The accessory name or empty to not match against the accessory name.
     **/
    string name;

    /**
     * The protocol supported by the accessory.
     **/
    string protocol;
  };

};
"
`;

exports[`Built-in slices IceLocatorDiscovery/IceLocatorDiscovery.ice 1`] = `
"#pragma once

[[\\"cpp:doxygen:include:IceLocatorDiscovery/IceLocatorDiscovery.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceLocatorDiscovery\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Locator.ice>

/**
 * IceLocatorDiscovery is an Ice plug-in that enables the discovery of IceGrid
 * and custom locators via UDP multicast.
 **/
module IceLocatorDiscovery {
  /**
   * The Ice lookup reply interface must be implemented by clients which are
   * searching for Ice locators. Ice locator implementations invoke on this
   * interface to provide their locator proxy.
   *
   * @see Lookup
   **/
  interface LookupReply {
    /**
     * This method is called by the implementation of the Lookup interface to
     * reply to a findLocator request.
     *
     * @param prx The proxy of the locator.
     **/
    void foundLocator(Ice::Locator* prx);
  };

  /**
   * The Ice lookup interface is implemented by Ice locator implementations and
   * can be used by clients to find available Ice locators on the network.
   *
   * Ice locator implementations provide a well-known \`Ice/LocatorLookup' object
   * accessible through UDP multicast. Clients typically make a multicast
   * findLocator request to find the locator proxy.
   *
   * @see LookupReply
   **/
  interface Lookup {
    /**
     * Find a locator proxy with the given instance name.
     *
     * @param instanceName Restrict the search to Ice registries configured with
     * the given instance name. If empty, all the available registries will
     * reply.
     *
     * @param reply The reply object to use to send the reply.
     **/
    idempotent void findLocator(string instanceName, LookupReply* reply);
  };

};
"
`;

exports[`Built-in slices IcePatch2/FileInfo.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEPATCH2_API\\"]]
[[\\"cpp:doxygen:include:IcePatch2/IcePatch2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IcePatch2/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IcePatch2\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/BuiltinSequences.ice>

[\\"objc:prefix:ICEPATCH2\\"]
module IcePatch2 {
  /**
   * Basic information about a single file.
   **/
  struct FileInfo {
    string path;

    Ice::ByteSeq checksum;

    int size;

    bool executable;
  };

  /**
   * A sequence with information about many files.
   **/
  sequence<FileInfo> FileInfoSeq;

  /**
   * Basic information about a single file.
   **/
  struct LargeFileInfo {
    string path;

    Ice::ByteSeq checksum;

    long size;

    bool executable;
  };

  /**
   * A sequence with information about many files.
   **/
  sequence<LargeFileInfo> LargeFileInfoSeq;

};
"
`;

exports[`Built-in slices IcePatch2/FileServer.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICEPATCH2_API\\"]]
[[\\"cpp:doxygen:include:IcePatch2/IcePatch2.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IcePatch2/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IcePatch2\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <IcePatch2/FileInfo.ice>

/**
 * IcePatch can be used to update file hierarchies in a simple and efficient
 * manner. Checksums ensure file integrity, and data is compressed before
 * downloading.
 **/
[\\"objc:prefix:ICEPATCH2\\"]
module IcePatch2 {
  /**
   * A sequence of byte sequences. Each element is the checksum for a partition.
   **/
  sequence<Ice::ByteSeq> ByteSeqSeq;

  /**
   * A <code>partition</code> argument was not in the range 0-255.
   **/
  exception PartitionOutOfRangeException {};

  /**
   * This exception is raised if a file's contents cannot be read.
   **/
  exception FileAccessException {
    /**
     * An explanation of the reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception is raised if an operation tries to use a file whose size is
   * larger than 2.1 GB. Use the \\"large\\" versions of the operations instead.
   **/
  exception FileSizeRangeException extends FileAccessException {};

  /**
   * The interface that provides access to files.
   **/
  interface FileServer {
    /**
     * Return file information for the specified partition.
     *
     * <p class=\\"Deprecated\\"> This operation is deprecated and only present for
     * compatibility with old Ice clients (older than version 3.6).
     *
     * @param partition The partition number in the range 0-255.
     *
     * @return A sequence containing information about the files in the
     * specified partition.
     *
     * @throws PartitionOutOfRangeException If the partition number is out of
     * range.
     * @throws FileSizeRangeException If a file is larger than 2.1GB.
     **/
    [\\"deprecate:getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.\\", \\"nonmutating\\", \\"cpp:const\\"]
    idempotent FileInfoSeq getFileInfoSeq(int partition)
      throws PartitionOutOfRangeException, FileSizeRangeException;

    /**
     * Returns file information for the specified partition.
     *
     * @param partition The partition number in the range 0-255.
     *
     * @return A sequence containing information about the files in the
     * specified partition.
     *
     * @throws PartitionOutOfRangeException If the partition number is out of
     * range.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent LargeFileInfoSeq getLargeFileInfoSeq(int partition)
      throws PartitionOutOfRangeException;

    /**
     * Return the checksums for all partitions.
     *
     * @return A sequence containing 256 checksums. Partitions with a checksum
     * that differs from the previous checksum for the same partition contain
     * updated files. Partitions with a checksum that is identical to the
     * previous checksum do not contain updated files.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent ByteSeqSeq getChecksumSeq();

    /**
     * Return the master checksum for all partitions. If this checksum is the
     * same as for a previous run, the entire file set is up-to-date.
     *
     * @return The master checksum for the file set.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent Ice::ByteSeq getChecksum();

    /**
     * Read the specified file. This operation may only return fewer bytes than
     * requested in case there was an end-of-file condition.
     *
     * <p class=\\"Deprecated\\"> This operation is deprecated and only present for
     * compatibility with old Ice clients (older than version 3.6).
     *
     * @param path The pathname (relative to the data directory) for the file to
     * be read.
     *
     * @param pos The file offset at which to begin reading.
     *
     * @param num The number of bytes to be read.
     *
     * @return A sequence containing the compressed file contents.
     *
     * @throws FileAccessException If an error occurred while trying to read the
     * file.
     * @throws FileSizeRangeException If a file is larger than 2.1GB.
     **/
    [\\"deprecate:getFileCompressed() is deprecated, use getLargeFileCompressed() instead.\\", \\"amd\\", \\"nonmutating\\", \\"cpp:const\\", \\"cpp:array\\"]
    idempotent Ice::ByteSeq getFileCompressed(string path, int pos, int num)
      throws FileAccessException, FileSizeRangeException;

    /**
     * Read the specified file. This operation may only return fewer bytes than
     * requested in case there was an end-of-file condition.
     *
     * @param path The pathname (relative to the data directory) for the file to
     * be read.
     *
     * @param pos The file offset at which to begin reading.
     *
     * @param num The number of bytes to be read.
     *
     * @return A sequence containing the compressed file contents.
     *
     * @throws FileAccessException If an error occurred while trying to read the
     * file.
     **/
    [\\"amd\\", \\"nonmutating\\", \\"cpp:const\\", \\"cpp:array\\"]
    idempotent Ice::ByteSeq getLargeFileCompressed(
      string path,
      long pos,
      int num
    )
      throws FileAccessException;
  };

};
"
`;

exports[`Built-in slices IceSSL/ConnectionInfo.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICESSL_API\\"]]
[[\\"cpp:doxygen:include:IceSSL/IceSSL.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICESSL_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceSSL\\"]]
[[\\"cpp:include:IceSSL/Plugin.h\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Connection.ice>

[\\"objc:prefix:ICESSL\\", \\"swift:module:Ice:SSL\\"]
module IceSSL {
  /**
   * Provides access to the connection details of an SSL connection
   **/
  local class ConnectionInfo extends Ice::ConnectionInfo {
    string cipher;

    [\\"cpp:type:std::vector<CertificatePtr>\\", \\"java:type:java.security.cert.Certificate[]\\", \\"cs:type:System.Security.Cryptography.X509Certificates.X509Certificate2[]\\", \\"swift:type:[SecCertificate]\\"]
    Ice::StringSeq certs;

    bool verified;
  };

};
"
`;

exports[`Built-in slices IceSSL/ConnectionInfoF.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICESSL_API\\"]]
[[\\"cpp:doxygen:include:IceSSL/IceSSL.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICESSL_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceSSL\\"]]
[[\\"java:package:com.zeroc\\"]]

[\\"objc:prefix:ICESSL\\", \\"swift:module:Ice:SSL\\"]
module IceSSL {
  local class ConnectionInfo;

};
"
`;

exports[`Built-in slices IceSSL/EndpointInfo.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICESSL_API\\"]]
[[\\"cpp:doxygen:include:IceSSL/IceSSL.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICESSL_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceSSL\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Endpoint.ice>

[\\"objc:prefix:ICESSL\\", \\"swift:module:Ice:SSL\\"]
module IceSSL {
  /**
   * Provides access to an SSL endpoint information.
   **/
  local class EndpointInfo extends Ice::EndpointInfo {};

};
"
`;

exports[`Built-in slices IceStorm/IceStorm.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICESTORM_API\\"]]
[[\\"cpp:doxygen:include:IceStorm/IceStorm.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceStorm/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"js:module:ice\\"]]
[[\\"objc:dll-export:ICESTORM_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceStorm\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Identity.ice>
#include <Ice/SliceChecksumDict.ice>
#include <IceStorm/Metrics.ice>

/**
 * A messaging service with support for federation. In contrast to most other
 * messaging or event services, IceStorm supports typed events, meaning that
 * broadcasting a message over a federation is as easy as invoking a method on
 * an interface.
 **/
[\\"objc:prefix:ICESTORM\\"]
module IceStorm {
  interface Topic;

  /**
   * Information on the topic links.
   **/
  struct LinkInfo {
    /**
     * The linked topic.
     **/
    Topic* theTopic;

    /**
     * The name of the linked topic.
     **/
    string name;

    /**
     * The cost of traversing this link.
     **/
    int cost;
  };

  /**
   * A sequence of {@link LinkInfo} objects.
   **/
  sequence<LinkInfo> LinkInfoSeq;

  /**
   * This dictionary represents quality of service parameters.
   *
   * @see Topic#subscribeAndGetPublisher
   **/
  dictionary<string, string> QoS;

  /**
   * This exception indicates that an attempt was made to create a link that
   * already exists.
   **/
  exception LinkExists {
    /**
     * The name of the linked topic.
     **/
    string name;
  };

  /**
   * This exception indicates that an attempt was made to remove a link that
   * does not exist.
   **/
  exception NoSuchLink {
    /**
     * The name of the link that does not exist.
     **/
    string name;
  };

  /**
   * This exception indicates that an attempt was made to subscribe a proxy for
   * which a subscription already exists.
   **/
  exception AlreadySubscribed {};

  /**
   * This exception indicates that an attempt was made to subscribe a proxy that
   * is null.
   **/
  exception InvalidSubscriber {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * This exception indicates that a subscription failed due to an invalid QoS.
   **/
  exception BadQoS {
    /**
     * The reason for the failure.
     **/
    string reason;
  };

  /**
   * Publishers publish information on a particular topic. A topic logically
   * represents a type.
   *
   * @see TopicManager
   **/
  interface Topic {
    /**
     * Get the name of this topic.
     *
     * @return The name of the topic.
     *
     * @see TopicManager#create
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent string getName();

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a
     * topic, the publisher calls getPublisher and then casts to the topic type.
     * An unchecked cast must be used on this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy.
     *
     * @return A proxy to publish data on this topic.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent Object* getPublisher();

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To
     * publish data to a topic, the publisher calls getPublisher and then casts
     * to the topic type. An unchecked cast must be used on this proxy.
     *
     * @return A proxy to publish data on this topic.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent Object* getNonReplicatedPublisher();

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A
     * per-subscriber publisher object is returned.
     *
     * @param theQoS The quality of service parameters for this subscription.
     *
     * @param subscriber The subscriber's proxy.
     *
     * @return The per-subscriber publisher object.
     *
     * @throws AlreadySubscribed Raised if the subscriber object is already
     * subscribed.
     *
     * @throws InvalidSubscriber Raised if the subscriber object is null.
     *
     * @throws BadQoS Raised if the requested quality of service is unavailable
     * or invalid.
     *
     * @see #unsubscribe
     **/
    Object* subscribeAndGetPublisher(QoS theQoS, Object* subscriber)
      throws AlreadySubscribed, InvalidSubscriber, BadQoS;

    /**
     * Unsubscribe the given <code>subscriber</code>.
     *
     * @param subscriber The proxy of an existing subscriber.
     *
     * @see #subscribeAndGetPublisher
     **/
    idempotent void unsubscribe(Object* subscriber);

    /**
     * Create a link to the given topic. All events originating on this topic
     * will also be sent to <code>linkTo</code>.
     *
     * @param linkTo The topic to link to.
     *
     * @param cost The cost to the linked topic.
     *
     * @throws LinkExists Raised if a link to the same topic already exists.
     **/
    void link(Topic* linkTo, int cost) throws LinkExists;

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     *
     * @param linkTo The topic to destroy the link to.
     *
     * @throws NoSuchLink Raised if a link to the topic does not exist.
     **/
    void unlink(Topic* linkTo) throws NoSuchLink;

    /**
     * Retrieve information on the current links.
     *
     * @return A sequence of LinkInfo objects.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent LinkInfoSeq getLinkInfoSeq();

    /**
     * Retrieve the list of subscribers for this topic.
     *
     * @return The sequence of Ice identities for the subscriber objects.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] Ice::IdentitySeq getSubscribers();

    /**
     * Destroy the topic.
     **/
    void destroy();
  };

  /**
   * Mapping of topic name to topic proxy.
   **/
  dictionary<string, Topic*> TopicDict;

  /**
   * This exception indicates that an attempt was made to create a topic that
   * already exists.
   **/
  exception TopicExists {
    /**
     * The name of the topic that already exists.
     **/
    string name;
  };

  /**
   * This exception indicates that an attempt was made to retrieve a topic that
   * does not exist.
   **/
  exception NoSuchTopic {
    /**
     * The name of the topic that does not exist.
     **/
    string name;
  };

  /**
   * A topic manager manages topics, and subscribers to topics.
   *
   * @see Topic
   **/
  interface TopicManager {
    /**
     * Create a new topic. The topic name must be unique.
     *
     * @param name The name of the topic.
     *
     * @return A proxy to the topic instance.
     *
     * @throws TopicExists Raised if a topic with the same name already exists.
     **/
    Topic* create(string name) throws TopicExists;

    /**
     * Retrieve a topic by name.
     *
     * @param name The name of the topic.
     *
     * @return A proxy to the topic instance.
     *
     * @throws NoSuchTopic Raised if the topic does not exist.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Topic* retrieve(string name) throws NoSuchTopic;

    /**
     * Retrieve all topics managed by this topic manager.
     *
     * @return A dictionary of string, topic proxy pairs.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"] idempotent TopicDict retrieveAll();

    /**
     * Returns the checksums for the IceStorm Slice definitions.
     *
     * @return A dictionary mapping Slice type ids to their checksums.
     **/
    [\\"nonmutating\\", \\"cpp:const\\"]
    idempotent Ice::SliceChecksumDict getSliceChecksums();
  };

  /**
   * This inferface is advertised by the IceStorm service through the Ice object
   * with the identity \`IceStorm/Finder'. This allows clients to retrieve the
   * topic manager with just the endpoint information of the IceStorm service.
   **/
  interface Finder {
    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     *
     * @return The topic manager proxy.
     **/
    TopicManager* getTopicManager();
  };

};
"
`;

exports[`Built-in slices IceStorm/Metrics.ice 1`] = `
"#pragma once

[[\\"cpp:dll-export:ICESTORM_API\\"]]
[[\\"cpp:doxygen:include:IceStorm/IceStorm.h\\"]]
[[\\"cpp:header-ext:h\\"]]
[[\\"cpp:include:IceStorm/Config.h\\"]]
[[\\"ice-prefix\\"]]
[[\\"objc:dll-export:ICESTORM_API\\"]]
[[\\"objc:header-dir:objc\\"]]
[[\\"python:pkgdir:IceStorm\\"]]
[[\\"java:package:com.zeroc\\"]]

#include <Ice/Metrics.ice>

[\\"objc:prefix:ICEMX\\", \\"js:module:ice\\", \\"swift:module:IceStorm:MX\\"]
module IceMX {
  /**
   * Provides information on IceStorm topics.
   **/
  class TopicMetrics extends Metrics {
    /**
     * Number of events published on the topic by publishers.
     **/
    long published = 0;

    /**
     * Number of events forwarded on the topic by IceStorm topic links.
     **/
    long forwarded = 0;
  };

  /**
   * Provides information on IceStorm subscribers.
   **/
  class SubscriberMetrics extends Metrics {
    /**
     * Number of queued events.
     **/
    int queued = 0;

    /**
     * Number of outstanding events.
     **/
    int outstanding = 0;

    /**
     * Number of forwarded events.
     **/
    long delivered = 0;
  };

};
"
`;

exports[`Slices classes.ice 1`] = `
"#pragma once

module Test {
  class Empty {};

  class NonEmpty {
    string field;
  };
};
"
`;

exports[`Slices enums.ice 1`] = `
"#pragma once

module Test {
  enum Empty {};

  enum NonEmpty {
    One,
    Two,
  };
};
"
`;
